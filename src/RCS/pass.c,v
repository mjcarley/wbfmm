head	1.1;
access;
symbols;
locks
	ensmjc:1.1; strict;
comment	@ * @;


1.1
date	2019.06.20.16.54.56;	author ensmjc;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* This file is part of WBFMM, a Wide-Band Fast Multipole Method code
 *
 * Copyright (C) 2019 Michael Carley
 *
 * WBFMM is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.  WBFMM is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with WBFMM.  If not, see <https://www.gnu.org/licenses/>.
 */

/*
  functions for child-parent, parent-child, and other shifts in tree
  calculations
*/

#ifdef _HAVE_CONFIG_H_
#include <config.h>
#endif /*_HAVE_CONFIG_H_*/

#include <math.h>
#include <string.h>

#include <glib.h>

#include <wbfmm.h>

#include "wbfmm-private.h"

extern gint _shift_angles[] ;
extern WBFMM_REAL _shifts_ph[], _shifts_ch[] ;

static guint ilist4_orientation(guint64 i, guint64 j)

{
  guint idx ;
  guint32 xi, yi, zi, xj, yj, zj ;
  gint dx, dy, dz ;

  wbfmm_point_from_index(i, &xi, &yi, &zi) ;
  wbfmm_point_from_index(j, &xj, &yj, &zj) ;

  dx = (gint)xi - (gint)xj ;
  dy = (gint)yi - (gint)yj ;
  dz = (gint)zi - (gint)zj ;

  idx = (dx+3)*49+(dy+3)*7+dz+3 ;

  g_assert(idx >= 0 && idx < 343) ;

  return idx ;
}

gint FUNCTION_NAME(wbfmm_downward_pass)(wbfmm_tree_t *t,
					wbfmm_shift_operators_t *op,
					guint level, WBFMM_REAL *work)

{
  guint nb, Ns, Nr, ni, nerot, necx, ncs, ncr, idx4, j, Nc, Np ;
  gint ith, iph ;
  guint64 ip, ic, ilist[189] ;
  wbfmm_box_t *bp, *bc ;
  WBFMM_REAL *rotations, *shifts, ph, ch, *H, *Cx, *wks, *wkr ;
  WBFMM_REAL *H03, *H47, *trans ;
  /* WBFMM_REAL xi[3], xj[3], th0, ch0, ph0, r, wb ; */

  g_assert(level > 1) ;

  /*number of boxes at this level*/
  nb = 1 << 3*(level) ;

  /*singular and regular expansion orders at this level*/
  Ns = t->order_s[level] ; Nr = t->order_r[level] ;
  ncs = wbfmm_coefficient_index_nm(Ns+1,0) ;
  ncr = wbfmm_coefficient_index_nm(Nr+1,0) ;
  wks = work ; wkr = &(wks[2*ncs]) ;

  /*boxes at this level (parent)*/
  bp = t->boxes[level] ;

  /*rotation and shift operators*/
  rotations = (WBFMM_REAL *)(op->rotations) ;
  H03 = &(rotations[12*(op->nerot)]) ;
  H47 = &(rotations[36*(op->nerot)]) ;
  shifts = (WBFMM_REAL *)(op->SR[level]) ;

  /*number of elements in rotation and translation operators*/
  nerot =   wbfmm_element_number_rotation(op->Lmax) ;
  necx  = 2*wbfmm_element_number_coaxial(op->L[level]) ;

  /*interaction list 4, loop on boxes at this level*/
  for ( ip = 0 ; ip < nb ; ip ++ ) {
    /* FUNCTION_NAME(wbfmm_tree_box_centre)(t, level, ip, xi, &wb) ; */
    /*locate boxes in interaction list*/
    ni = wbfmm_box_interaction_list_4(level, ip, ilist) ;
    /*loop on interaction list and compute SR-shifted fields*/
    for ( j = 0 ; j < ni ; j ++ ) {
      /* FUNCTION_NAME(wbfmm_tree_box_centre)(t, level, ilist[j], xj, &wb) ; */
      /* FUNCTION_NAME(wbfmm_shift_angles)(xj, xi, &th0, &ph0, &ch0, &r) ; */

      /*find entry in shift lookup tables*/
      idx4 = ilist4_orientation(ilist[j], ip) ;
      /*index of rotation operator*/
      ith = _shift_angles[4*idx4+0] ;
      H = &(rotations[ith*nerot]) ;

      /* fprintf(stderr, "%d\n", ith) ; */
      /* g_assert(fabs(th0-_shifts_th[ith]) < 1e-4) ; */

      /*index of translation operator*/
      ith = _shift_angles[4*idx4+3] ;
      Cx = &(shifts[ith*necx]) ;

      /* g_assert(fabs(r - _shifts_r[ith]*wb) < 1e-4) ; */
      /* fprintf(stderr, "%g %g\n", r, _shifts_r[ith]*wb) ; */

      /*rotation angles \phi and \chi*/
      iph =  _shift_angles[4*idx4+1] ;
      ph = (iph >= 0 ? _shifts_ph[iph-1] : -_shifts_ph[-1-iph]) ;
      iph =  _shift_angles[4*idx4+2] ;
      ch = (iph >= 0 ? _shifts_ph[iph-1] : -_shifts_ph[-1-iph]) ;

      /* g_assert(fabs(ph0-ph) < 1e-4) ; */
      /* g_assert(fabs(ch0-ch) < 1e-4) ; */

      /*rotate singular coefficients into wks*/
      memset(wks, 0, 2*ncs*sizeof(WBFMM_REAL)) ;
      FUNCTION_NAME(wbfmm_rotate_H)(wks, 1, Ns, bp[ilist[j]].mps, 8, 
				    H, ph, ch) ;
      /*translate into wkr*/
      memset(wkr, 0, 2*ncr*sizeof(WBFMM_REAL)) ;
      FUNCTION_NAME(wbfmm_coaxial_translate)(wkr, 1, Nr, wks, 1, Ns, 
					     Cx, Nr, TRUE) ;
      /*rotate regular coefficients into mpr*/
      FUNCTION_NAME(wbfmm_rotate_H)(bp[ip].mpr, 8, Nr, wkr, 1,
				    H, ch, ph) ;
    }
  }

  /*no downward shift at the deepest level*/
  if ( level == t-> depth ) return 0 ;
  
  Np = t->order_r[level  ] ;
  Nc = t->order_r[level+1] ;
  bc = t->boxes[level+1] ;
  trans = (WBFMM_REAL *)(op->SS[level+1]) ;
  for ( ip = 0 ; ip < nb ; ip ++ ) {
    ic = wbfmm_box_first_child(ip) ;
    FUNCTION_NAME(wbfmm_parent_child_shift)((WBFMM_REAL *)(bc[ic].mpr), Nc,
    					    (WBFMM_REAL *)(bp[ip].mpr), Np,
    					    H03, H47, Np,
    					    trans, Np, work) ;
    
  }

  return 0 ;
}

gint FUNCTION_NAME(wbfmm_upward_pass)(wbfmm_tree_t *t,
				      wbfmm_shift_operators_t *op,
				      guint level, WBFMM_REAL *work)

{
  guint np, Np, Nc ;
  guint64 ip, ic;
  wbfmm_box_t *bp, *bc ;
  WBFMM_REAL *H03, *H47, *trans, *rotations ;

  g_assert(level > 1) ;

  /*number of parent boxes into which to shift child data*/
  np = 1 << 3*(level-1) ;

  /*expansion orders at parent and child levels*/
  Np = t->order_s[level-1] ;
  Nc = t->order_s[level  ] ;

  /*parent and child boxes*/
  bp = t->boxes[level-1] ;
  bc = t->boxes[level  ] ;

  /*rotation and shift operators*/
  rotations = (WBFMM_REAL *)(op->rotations) ;
  H03 = &(rotations[36*(op->nerot)]) ;
  H47 = &(rotations[12*(op->nerot)]) ;
  trans = (WBFMM_REAL *)(op->SS[level]) ;

  for ( ip = 0 ; ip < np ; ip ++ ) {
    /*locate first child of parent box*/
    ic = wbfmm_box_first_child(ip) ;
    FUNCTION_NAME(wbfmm_child_parent_shift)((WBFMM_REAL *)(bp[ip].mps), Np,
					    (WBFMM_REAL *)(bc[ic].mps), Nc,
					    H03, H47, Np, 
					    trans, Np, work) ;
    /* fprintf(stderr, "%g\n", ((WBFMM_REAL *)(bp[ip].mps))[0]) ; */
  }

  return 0 ;
}
@
