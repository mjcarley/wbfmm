head	1.3;
access;
symbols;
locks
	ensmjc:1.3; strict;
comment	@ * @;


1.3
date	2019.06.20.16.54.56;	author ensmjc;	state Exp;
branches;
next	1.2;

1.2
date	2019.06.13.09.27.32;	author ensmjc;	state Exp;
branches;
next	1.1;

1.1
date	2019.05.30.15.34.34;	author ensmjc;	state Exp;
branches;
next	;


desc
@Evaluation of rotations of spherical harmonic expansions
@


1.3
log
@*** empty log message ***
@
text
@/* This file is part of WBFMM, a Wide-Band Fast Multipole Method code
 *
 * Copyright (C) 2019 Michael Carley
 *
 * WBFMM is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.  WBFMM is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with WBFMM.  If not, see <https://www.gnu.org/licenses/>.
 */

/*rotation operations using Gumerov and Duraiswami,
  http://dx.doi.org/10.1137/S1064827501399705 */

#ifdef _HAVE_CONFIG_H_
#include <config.h>
#endif /*_HAVE_CONFIG_H_*/

#include <math.h>
#include <string.h>

#include <glib.h>

#include <wbfmm.h>

#include "wbfmm-private.h"

/* #define CHECK_COEFFICIENTS */

#ifdef CHECK_COEFFICIENTS
#include <stdio.h>
#endif

#ifdef CHECK_COEFFICIENTS
static gint rotation_coefficients_check_recursion(WBFMM_REAL *H, WBFMM_REAL Cth,
						  WBFMM_REAL Sth, gint N)

{
  gint n, m, nu, idx1, idx2, idx3, idx4 ;
  WBFMM_REAL b1, b2, b3, a4, err, emax ;

  /*recursion (5.55)*/
  emax = 0.0 ;
  for ( n = 2 ; n <= N ; n ++ ) {
    for ( nu = -n+1 ; nu <= n-1 ; nu ++ ) {
      for ( m = 0 ; m <= n-1 ; m ++ ) {
	idx1 = wbfmm_rotation_index_numn(nu  , m+1, n-1) ;
	idx2 = wbfmm_rotation_index_numn(nu+1, m  , n  ) ;
	idx3 = wbfmm_rotation_index_numn(nu-1, m  , n  ) ;
	idx4 = wbfmm_rotation_index_numn(nu  , m  , n  ) ;
	b1 = recursion_bnm(n  ,  m   ) ;
	b2 = recursion_bnm(n  , -nu-1) ;
	b3 = recursion_bnm(n  ,  nu-1) ;
	a4 = recursion_anm(n-1,  nu  ) ;
	err = 2.0*b1*H[idx1] - b2*(1.0-Cth)*H[idx2] + b3*(1.0+Cth)*H[idx3] +
	  2.0*a4*Sth*H[idx4] ;
	emax = MAX(emax, ABS(err)) ;
	fprintf(stderr, "%2d %2d %2d %2d %+e (%lg,%lg,%lg,%lg)\n",
		n, nu, m, idx1, err, H[idx1], H[idx2], H[idx3], H[idx4]) ;
      }
    }
  }

  fprintf(stderr, "Maximum error in recursion relation (5.55): %e\n", emax) ;

  return 0 ;
}

#endif /*CHECK_COEFFICIENTS*/


gint FUNCTION_NAME(wbfmm_rotation_angles) (WBFMM_REAL *ix, WBFMM_REAL *iy,
					   WBFMM_REAL *iz, 
					   WBFMM_REAL *jx, WBFMM_REAL *jy,
					   WBFMM_REAL *jz, 
					   WBFMM_REAL *th, WBFMM_REAL *ph,
					   WBFMM_REAL *ch)

/*
  rotation angles in G&D section 5
  
  (ix,iy,iz) unit vectors on coordinate axes in initial system
  (jx,jy,jz) unit vectors on coordinate axes in rotated system
*/

{
  WBFMM_REAL ex, ey, ez ;

  ex = ix[0]*jz[0] + ix[1]*jz[1] + ix[2]*jz[2] ;
  ey = iy[0]*jz[0] + iy[1]*jz[1] + iy[2]*jz[2] ;
  ez = iz[0]*jz[0] + iz[1]*jz[1] + iz[2]*jz[2] ;

  *th = ACOS(ez) ;
  *ch = ATAN2(ey, ex) ;

  ex = jx[0]*iz[0] + jx[1]*iz[1] + jx[2]*iz[2] ;
  ey = jy[0]*iz[0] + jy[1]*iz[1] + jy[2]*iz[2] ;

  *ph = ATAN2(ey, ex) ;
  
  return 0 ;
}

gint FUNCTION_NAME(wbfmm_coefficients_H_rotation)(WBFMM_REAL *H, gint N, 
						  WBFMM_REAL th, 
						  WBFMM_REAL *work)

{
  WBFMM_REAL Cth, Sth, *Pnm1, *Pn, b1, b2, b, a3, *h ;
  gint idx, n, m, nu, idx1, idx2, idx3 ;

  /*note that with the G&D normalization, the Legendre polynomials in
    (5.48) are related to the normalized Legendre polynomials by a
    scaling (-1)^m*sqrt(2n+1)/sqrt(4\pi)*/
  Pnm1 = &(work[0]) ; Pn = &(Pnm1[2*(2*N+1)]) ;
  h = &(Pn[2*(2*N+1)]) ;

  Cth = COS(th) ; Sth = SIN(th) ;

  /*initialize the m=0 entries of H, G&D (5.48)*/
  FUNCTION_NAME(wbfmm_legendre_init)(Cth, Sth, &(Pnm1[0]), &(Pn[0]), &(Pn[1])) ;
  n = 0 ; m = 0 ;
  nu = 0 ;
  idx = wbfmm_rotation_index_numn(nu, m, n) ;
  h[idx] = Pnm1[nu]/sqrt(2*n+1)*sqrt(4.0*M_PI) ;

  n = 1 ;
  for ( nu = 0 ; nu <= n ; nu ++ ) {
    idx  = wbfmm_rotation_index_numn( nu, m, n) ;
    idx1 = wbfmm_rotation_index_numn(-nu, m, n) ;
    h[idx] = h[idx1] = Pn[nu]/sqrt(2*n+1)*sqrt(4.0*M_PI) ;
  }

  for ( n = 2 ; n <= 2*N ; n ++ ) {
    FUNCTION_NAME(wbfmm_legendre_recursion_array)(&Pnm1, &Pn, n-1, Cth, Sth) ;
    for ( nu = 0 ; nu <= n ; nu ++ ) {
      idx  = wbfmm_rotation_index_numn( nu, m, n) ;
      idx1 = wbfmm_rotation_index_numn(-nu, m, n) ;
      h[idx] = h[idx1] = Pn[nu]/sqrt(2*n+1)*sqrt(4.0*M_PI) ;
    }
  }

  /*apply recursion 5.55, in this order to advance (nu,n) planes in
    the direction of increasing m*/
  for ( m = 0 ; m <= N ; m ++ ) {
    for ( n = m+2 ; n <= 2*N-m ; n ++ ) {
      for ( nu = -n+1 ; nu <= n-1 ; nu ++ ) {
	b  = FUNCTION_NAME(recursion_bnm)(n, m) ;
	b1 = FUNCTION_NAME(recursion_bnm)(n, -nu-1) ;
	b2 = FUNCTION_NAME(recursion_bnm)(n, nu-1) ;
	a3 = FUNCTION_NAME(recursion_anm)(n-1, nu) ;
	idx  = wbfmm_rotation_index_numn(nu  , m+1, n-1) ;
	idx1 = wbfmm_rotation_index_numn(nu+1, m  , n  ) ;
	idx2 = wbfmm_rotation_index_numn(nu-1, m  , n  ) ;
	idx3 = wbfmm_rotation_index_numn(nu  , m  , n  ) ;
	h[idx] = (0.5*(b1*(1.0 - Cth)*h[idx1] - b2*(1.0 + Cth)*h[idx2]) -
		  a3*Sth*h[idx3])/b ;
      }
    }
  }

  memcpy(H, h, wbfmm_rotation_index_numn(N+1,0,N+1)*sizeof(WBFMM_REAL)) ;

#ifdef CHECK_COEFFICIENTS
  rotation_coefficients_check_recursion(H, Cth, Sth, N) ;

#endif /*CHECK_COEFFICIENTS*/

  return 0 ;
}

gint FUNCTION_NAME(wbfmm_rotate_H)(WBFMM_REAL *Co, gint cstro, 
				   gint N, WBFMM_REAL *Ci, gint cstri,
				   WBFMM_REAL *H,
				   WBFMM_REAL ph, WBFMM_REAL ch)

/*
  apply rotation (matrix H from wbfmm_coefficients_H_rotation) to
  rotate input coefficients Ci into output Co, through angles
  (th,ph,ch), G&D, section 6, and (2.27)
*/

{
  gint nu, n, m, offi, offp, offm ;
  WBFMM_REAL Cmch, Smch, Cnph, Snph, Cch, Sch, Cph, Sph ;
  WBFMM_REAL tmp, Hp, Hm, CC, SS, CS, SC ;
  WBFMM_REAL HpCC, HmCC, HpSS, HmSS, HpCS, HmCS, HpSC, HmSC ;
  /* WBFMM_REAL Er, Ei ; */

  /*initialize recursions*/
  Cph = COS(ph) ; Sph = SIN(ph) ;
  Cch = COS(ch) ; Sch = SIN(ch) ;

  /* inside loops, trigonmetric quantities are calculated using
   * recursions and take the following values:
   *
   * Smch = SIN(m*ch) ; Cmch = COS(m*ch) ;
   * Cnph = COS(nu*ph) ; Snph = SIN(nu*ph) ;
   * 
   * Er + j Ei = \exp(j(\pm m\chi - \pm \nu\phi))
   * Er = COS(m*ch-nu*ph) ; Ei = SIN(m*ch-nu*ph)
   *
   * CC = COS(m*ch)*COS(nu*ph) 
   * SC = SIN(m*ch)*COS(nu*ph) 
   * CS = COS(m*ch)*SIN(nu*ph) 
   * SS = SIN(m*ch)*SIN(nu*ph) 
   *
   * offX (X = `p', `m') = offset into array, `p' for `plus' indices,
   * `m' for `minus'
   */

  for ( n = 0 ; n <= N ; n ++ ) {
    WBFMM_REAL buf[4] ;
    nu = 0 ; Cnph = 1.0 ; Snph = 0.0 ;

    /* offp = 2*cstro*wbfmm_coefficient_index_nm(n,nu) ; */

    m = 0 ; Cmch = 1.0 ; Smch = 0.0 ;

    offp = 2*cstri*wbfmm_coefficient_index_nm(n,m) ;
    Hp = H[wbfmm_rotation_index_numn(nu,m,n)] ;

    CC = Cmch*Cnph ; SS = Smch*Snph ;
    CS = Cmch*Snph ; SC = Smch*Cnph ;

    HpCC = Hp*CC ; HpSS = Hp*SS ;
    HpCS = Hp*CS ; HpSC = Hp*SC ;
    /* Er = Hp*(CC + SS) ; Ei = Hp*(SC - CS) ; */

    /* Co[offp+0] += Er*Ci[offi+0] - Ei*Ci[offi+1] ; */
    /* Co[offp+1] += Er*Ci[offi+1] + Ei*Ci[offi+0] ; */
    /* Er = Hp*(CC + SS) ; Ei = Hp*(SC - CS) ; */

    /* Co[offp+0] +=  */
    buf[0] = 
      (HpCC + HpSS)*Ci[offp+0] - (HpSC - HpCS)*Ci[offp+1] ;
    /* Co[offp+1] +=  */
    buf[1] = 
      (HpCC + HpSS)*Ci[offp+1] + (HpSC - HpCS)*Ci[offp+0] ;
      
    for ( m = 1 ; m <= n ; m ++ ) {
      offp = 2*cstri*wbfmm_coefficient_index_nm(n,m) ;
      Hp = H[wbfmm_rotation_index_numn( nu,m,n)] ;
      Hm = H[wbfmm_rotation_index_numn(-nu,m,n)] ;

      tmp = Cmch ; 
      Cmch = Cmch*Cch - Smch*Sch ;
      Smch = Smch*Cch + tmp*Sch ;

      CC = Cmch*Cnph ; SS = Smch*Snph ;
      CS = Cmch*Snph ; SC = Smch*Cnph ;

      HmCC = Hm*CC ; HpCC = Hp*CC ;
      HmSS = Hm*SS ; HpSS = Hp*SS ;
      HmCS = Hm*CS ; HpCS = Hp*CS ;
      HmSC = Hm*SC ; HpSC = Hp*SC ;

      /* Er = Hp*(CC + SS) ; Ei = Hp*(SC - CS) ; */

      /* Co[offp+0] +=  */
      buf[0] += 
	(HpCC + HpSS)*Ci[offp+0] - (HpSC - HpCS)*Ci[offp+1] ;
      /* Co[offp+1] +=  */
      buf[1] += 
	(HpCC + HpSS)*Ci[offp+1] + (HpSC - HpCS)*Ci[offp+0] ;
      
      offm = 2*cstri*wbfmm_coefficient_index_nm(n,-m) ;

      /* Er = Hm*( CC - SS) ; Ei = Hm*(-SC - CS) ; */

      /* Co[offp+0] +=  */
      buf[0] += 
	(HmCC - HmSS)*Ci[offm+0] + (HmSC + HmCS)*Ci[offm+1] ;
      /* Co[offp+1] +=  */
      buf[1] += 
	(HmCC - HmSS)*Ci[offm+1] - (HmSC + HmCS)*Ci[offm+0] ;
      

      /* Er = Hp*(CC + SS) ; Ei = Hp*(SC - CS) ; */

      /* Co[offp+0] += Er*Ci[offi+0] - Ei*Ci[offi+1] ; */
      /* Co[offp+1] += Er*Ci[offi+1] + Ei*Ci[offi+0] ; */
      
      /* offi = 2*cstri*wbfmm_coefficient_index_nm(n,-m) ; */

      /* Er = Hm*( CC - SS) ; Ei = Hm*(-SC - CS) ; */

      /* Co[offp+0] += Er*Ci[offi+0] - Ei*Ci[offi+1] ; */
      /* Co[offp+1] += Er*Ci[offi+1] + Ei*Ci[offi+0] ; */
    }

    offp = 2*cstro*wbfmm_coefficient_index_nm(n, nu) ;
    Co[offp+0] += buf[0] ; Co[offp+1] += buf[1] ;
    
    for ( nu = 1 ; nu <= n ; nu ++ ) {
      tmp = Cnph ; 
      Cnph = Cnph*Cph - Snph*Sph ;
      Snph = Snph*Cph + tmp*Sph ;

      m = 0 ; Cmch = 1.0 ; Smch = 0.0 ;

      offp = 2*cstri*wbfmm_coefficient_index_nm(n,m) ;

      Hp = H[wbfmm_rotation_index_numn( nu,m,n)] ;
      Hm = H[wbfmm_rotation_index_numn(-nu,m,n)] ;

      CC = Cmch*Cnph ; SS = Smch*Snph ;
      CS = Cmch*Snph ; SC = Smch*Cnph ;

      HmCC = Hm*CC ; HpCC = Hp*CC ;
      HmSS = Hm*SS ; HpSS = Hp*SS ;
      HmCS = Hm*CS ; HpCS = Hp*CS ;
      HmSC = Hm*SC ; HpSC = Hp*SC ;

      buf[0] = 
	(HpCC + HpSS)*Ci[offp+0] - (HpSC - HpCS)*Ci[offp+1] ;
      buf[1] = 
	(HpCC + HpSS)*Ci[offp+1] + (HpSC - HpCS)*Ci[offp+0] ;
      buf[2] = 
	(HmCC - HmSS)*Ci[offp+0] - (HmSC + HmCS)*Ci[offp+1] ;
      buf[3] = 
	(HmCC - HmSS)*Ci[offp+1] + (HmSC + HmCS)*Ci[offp+0] ;

      /*+\nu*/
      /* Er = Hp*(CC + SS) ; Ei = Hp*(SC - CS) ; */

      /* buf[0] += Er*Ci[offi+0] - Ei*Ci[offi+1] ; */
      /* buf[1] += Er*Ci[offi+1] + Ei*Ci[offi+0] ; */

      /* /\*-\nu*\/ */
      /* Er = Hm*(CC - SS) ; Ei = Hm*(SC + CS) ; */

      /* buf[2] += Er*Ci[offi+0] - Ei*Ci[offi+1] ; */
      /* buf[3] += Er*Ci[offi+1] + Ei*Ci[offi+0] ; */

      for ( m = 1 ; m <= n ; m ++ ) {
	/*rotation coefficients for \pm\nu*/
	Hp = H[wbfmm_rotation_index_numn( nu,m,n)] ;
	Hm = H[wbfmm_rotation_index_numn(-nu,m,n)] ;

	tmp = Cmch ; 
	Cmch = Cmch*Cch - Smch*Sch ;
	Smch = Smch*Cch + tmp*Sch ;

	CC = Cmch*Cnph ; SS = Smch*Snph ;
	CS = Cmch*Snph ; SC = Smch*Cnph ;

	HmCC = Hm*CC ; HpCC = Hp*CC ;
	HmSS = Hm*SS ; HpSS = Hp*SS ;
	HmCS = Hm*CS ; HpCS = Hp*CS ;
	HmSC = Hm*SC ; HpSC = Hp*SC ;

	offp = 2*cstri*wbfmm_coefficient_index_nm(n, m) ;
	offm = 2*cstri*wbfmm_coefficient_index_nm(n,-m) ;

	buf[0] += 
	  (HpCC + HpSS)*Ci[offp+0] - (HpSC - HpCS)*Ci[offp+1] +
	  (HmCC - HmSS)*Ci[offm+0] + (HmSC + HmCS)*Ci[offm+1] ;
	buf[1] += 
	  (HpCC + HpSS)*Ci[offp+1] + (HpSC - HpCS)*Ci[offp+0] +
	  (HmCC - HmSS)*Ci[offm+1] - (HmSC + HmCS)*Ci[offm+0] ;
	buf[2] += 
	  (HmCC - HmSS)*Ci[offp+0] - (HmSC + HmCS)*Ci[offp+1] +
	  (HpCC + HpSS)*Ci[offm+0] + (HpSC - HpCS)*Ci[offm+1] ;
	buf[3] += 
	  (HmCC - HmSS)*Ci[offp+1] + (HmSC + HmCS)*Ci[offp+0] +
	  (HpCC + HpSS)*Ci[offm+1] + (HpCS - HpSC)*Ci[offm+0] ;

	/* Er = Hp*(CC + SS) ; Ei = Hp*(SC - CS) ; */
	/* Er = HpCC + HpSS ; Ei = HpSC - HpCS ; */
	/* buf[0] += Er*Ci[offp+0] - Ei*Ci[offp+1] ; */
	/* buf[1] += Er*Ci[offp+1] + Ei*Ci[offp+0] ; */

	/* Er = Hm*( CC - SS) ; Ei = Hm*(-SC - CS) ; */
	/* Er = HmCC - HmSS ; Ei = -HmSC - HmCS ; */

	/* buf[0] += Er*Ci[offm+0] - Ei*Ci[offm+1] ; */
	/* buf[1] += Er*Ci[offm+1] + Ei*Ci[offm+0] ; */

	/* Er = Hm*(CC - SS) ; Ei = Hm*(SC + CS) ; */
	/* buf[2] += Er*Ci[offp+0] - Ei*Ci[offp+1] ; */
	/* buf[3] += Er*Ci[offp+1] + Ei*Ci[offp+0] ; */
	/* Er = HmCC - HmSS ; Ei = HmSC + HmCS ; */


	/* Er = Hp*( CC + SS) ; Ei = Hp*(-SC + CS) ; */
	/* Er = HpCC + HpSS ; Ei = -HpSC + HpCS ; */
	/* buf[2] += Er*Ci[offm+0] - Ei*Ci[offm+1] ; */
	/* buf[3] += Er*Ci[offm+1] + Ei*Ci[offm+0] ; */

      }
      /*output indices for \pm\nu*/
      offp = 2*cstro*wbfmm_coefficient_index_nm(n, nu) ;
      offm = 2*cstro*wbfmm_coefficient_index_nm(n,-nu) ;
      Co[offp+0] += buf[0] ; Co[offp+1] += buf[1] ;
      Co[offm+0] += buf[2] ; Co[offm+1] += buf[3] ;
    }
  }

  /* for ( n = 0 ; n <= N ; n ++ ) { */
  /*   for ( nu = -n ; nu <= n ; nu ++ ) { */
  /*     idxo = wbfmm_coefficient_index_nm(n,nu) ; */

  /*     m = 0 ;  */
  /*     idxi = wbfmm_coefficient_index_nm(n,m) ; */
  /*     idxh = wbfmm_rotation_index_numn(nu,m,n) ; */
  /*     Er = COS(m*ch-nu*ph) ; Ei = SIN(m*ch-nu*ph) ; */
  /*     Co[2*idxo*cstro+0] +=  */
  /* 	(Er*Ci[2*idxi*cstri+0] - Ei*Ci[2*idxi*cstri+1])*H[idxh] ; */
  /*     Co[2*idxo*cstro+1] +=  */
  /* 	(Er*Ci[2*idxi*cstri+1] + Ei*Ci[2*idxi*cstri+0])*H[idxh] ; */

  /*     for ( m = 1 ; m <= n ; m ++ ) { */
  /* 	idxi = wbfmm_coefficient_index_nm(n,m) ; */
  /* 	idxh = wbfmm_rotation_index_numn(nu,m,n) ; */
  /* 	Er = COS(m*ch-nu*ph) ; Ei = SIN(m*ch-nu*ph) ; */
  /* 	Co[2*idxo*cstro+0] +=  */
  /* 	  (Er*Ci[2*idxi*cstri+0] - Ei*Ci[2*idxi*cstri+1])*H[idxh] ; */
  /* 	Co[2*idxo*cstro+1] +=  */
  /* 	  (Er*Ci[2*idxi*cstri+1] + Ei*Ci[2*idxi*cstri+0])*H[idxh] ; */

  /* 	idxi = wbfmm_coefficient_index_nm(n,-m) ; */
  /* 	idxh = wbfmm_rotation_index_numn(-nu,m,n) ; */
  /* 	Er = COS(-m*ch-nu*ph) ; Ei = SIN(-m*ch-nu*ph) ; */
  /* 	Co[2*idxo*cstro+0] +=  */
  /* 	  (Er*Ci[2*idxi*cstri+0] - Ei*Ci[2*idxi*cstri+1])*H[idxh] ; */
  /* 	Co[2*idxo*cstro+1] +=  */
  /* 	  (Er*Ci[2*idxi*cstri+1] + Ei*Ci[2*idxi*cstri+0])*H[idxh] ; */
  /*     } */
  /*   } */
  /* } */

  return 0 ;
}

@


1.2
log
@*** empty log message ***
@
text
@d115 1
a115 1
  gint idx, n, m, nu, idx1, idx2, idx3, sgn ;
d117 3
d130 1
a130 1
  h[idx] = Pnm1[nu]/sqrt(2*n+1) ;
d132 1
a132 1
  n = 1 ; sgn = 1 ;
d136 1
a136 2
    h[idx] = h[idx1] = sgn*Pn[nu]/sqrt(2*n+1) ;
    sgn = -sgn ;
a140 1
    sgn = 1 ;
d144 1
a144 3
      h[idx] = h[idx1] = sgn*Pn[nu]/sqrt(2*n+1) ;

      sgn = -sgn ;
d183 3
a185 3
  apply rotation (matrix H from coefficients_H_rotation) to rotate
  input coefficients Ci into output Co, through angles (th,ph,ch),
  G&D, section 6, and (2.27)
d189 27
a215 2
  gint nu, n, m, idxi, idxo, idxh ;
  WBFMM_REAL Er, Ei ;
d218 78
a295 2
    for ( nu = -n ; nu <= n ; nu ++ ) {
      idxo = wbfmm_coefficient_index_nm(n,nu) ;
d297 43
a339 8
      m = 0 ; 
      idxi = wbfmm_coefficient_index_nm(n,m) ;
      idxh = wbfmm_rotation_index_numn(nu,m,n) ;
      Er = COS(m*ch-nu*ph) ; Ei = SIN(m*ch-nu*ph) ;
      Co[2*idxo*cstro+0] += 
	(Er*Ci[2*idxi*cstri+0] - Ei*Ci[2*idxi*cstri+1])*H[idxh] ;
      Co[2*idxo*cstro+1] += 
	(Er*Ci[2*idxi*cstri+1] + Ei*Ci[2*idxi*cstri+0])*H[idxh] ;
d342 54
a395 19
	idxi = wbfmm_coefficient_index_nm(n,m) ;
	idxh = wbfmm_rotation_index_numn(nu,m,n) ;
	Er = COS(m*ch-nu*ph) ; Ei = SIN(m*ch-nu*ph) ;
	/* Co[2*idxo+0] += (Er*Ci[2*idxi+0] - Ei*Ci[2*idxi+1])*H[idxh] ; */
	/* Co[2*idxo+1] += (Er*Ci[2*idxi+1] + Ei*Ci[2*idxi+0])*H[idxh] ; */
	Co[2*idxo*cstro+0] += 
	  (Er*Ci[2*idxi*cstri+0] - Ei*Ci[2*idxi*cstri+1])*H[idxh] ;
	Co[2*idxo*cstro+1] += 
	  (Er*Ci[2*idxi*cstri+1] + Ei*Ci[2*idxi*cstri+0])*H[idxh] ;

	idxi = wbfmm_coefficient_index_nm(n,-m) ;
	idxh = wbfmm_rotation_index_numn(-nu,m,n) ;
	Er = COS(-m*ch-nu*ph) ; Ei = SIN(-m*ch-nu*ph) ;
	/* Co[2*idxo+0] += (Er*Ci[2*idxi+0] - Ei*Ci[2*idxi+1])*H[idxh] ; */
	/* Co[2*idxo+1] += (Er*Ci[2*idxi+1] + Ei*Ci[2*idxi+0])*H[idxh] ; */
	Co[2*idxo*cstro+0] += 
	  (Er*Ci[2*idxi*cstri+0] - Ei*Ci[2*idxi*cstri+1])*H[idxh] ;
	Co[2*idxo*cstro+1] += 
	  (Er*Ci[2*idxi*cstri+1] + Ei*Ci[2*idxi*cstri+0])*H[idxh] ;
d397 5
d405 33
d440 1
@


1.1
log
@Initial revision
@
text
@a88 4

  this gives correct answers for the rotation operation (see below) as
  long as the new coordinate system is not a pure rotation about z
  (and if it is, why are you rotating it at all?)
d109 3
a111 2
gint FUNCTION_NAME(coefficients_H_rotation)(WBFMM_REAL *H, gint N, 
					    WBFMM_REAL th, WBFMM_REAL *work)
@
