head	1.3;
access;
symbols;
locks
	ensmjc:1.3; strict;
comment	@ * @;


1.3
date	2019.06.20.16.54.56;	author ensmjc;	state Exp;
branches;
next	1.2;

1.2
date	2019.06.13.09.27.32;	author ensmjc;	state Exp;
branches;
next	1.1;

1.1
date	2019.05.30.15.34.34;	author ensmjc;	state Exp;
branches;
next	;


desc
@Coaxial translation operators
@


1.3
log
@*** empty log message ***
@
text
@/* This file is part of WBFMM, a Wide-Band Fast Multipole Method code
 *
 * Copyright (C) 2019 Michael Carley
 *
 * WBFMM is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.  WBFMM is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with WBFMM.  If not, see <https://www.gnu.org/licenses/>.
 */

/*translation operations using Gumerov and Duraiswami,
  http://dx.doi.org/10.1137/S1064827501399705 */

#ifdef _HAVE_CONFIG_H_
#include <config.h>
#endif /*_HAVE_CONFIG_H_*/

#include <math.h>
#include <string.h>

#include <glib.h>

#include <wbfmm.h>

#include "wbfmm-private.h"

/* #define CHECK_COEFFICIENTS */

#ifdef CHECK_COEFFICIENTS
#include <stdio.h>
#endif


/* #define recursion_anm(_n,_m)						\ */
/*   (((_n) < (ABS(_m))) ? 0 :						\ */
/*    (sqrt((WBFMM_REAL)((_n)+1+ABS(_m))*((_n)+1-ABS(_m))/(2*(_n)+1)/(2*(_n)+3)))) */

/* WBFMM_REAL recursion_anm(gint n, gint m) ; */
/* WBFMM_REAL recursion_bnm(gint n, gint m) ; */

/* gint coaxial_index(gint l, gint m, gint n, gint *idx, gint *sgn) ; */

#ifdef CHECK_COEFFICIENTS

gint coaxial_index(gint l, gint m, gint n, gint *idx, gint *sgn)

/*
  generate the index into the coefficient matrix for general l,m,n,

  l >= 0, n >= 0, -n <= m <= n

  sgn is the sign multiplier for the coefficient, i.e. use
  sgn*cfft[idx] (see G&D, 4.82)
*/

{
  m = ABS(m) ;

  if ( m > n ) { g_assert_not_reached() ; *idx = *sgn = 0 ; return 0 ; }

  if ( l >= n ) {
    *idx = wbfmm_coaxial_index_lmn(l, m, n) ;
    *sgn = 1 ;
    g_assert(*idx >= 0) ;
    return 0 ;
  }

  *idx = wbfmm_coaxial_index_lmn(n, m, l) ;
  *sgn = minus_one_pow(n+l) ;
  g_assert(*idx >= 0) ;

  return 0 ;
}

static gint coaxial_coefficient_recursion_check(WBFMM_REAL *cfft, gint L)

{
  gint l, m, n, i1, i2, i3, i4, sgn ;
  WBFMM_REAL a1, a2, a3, a4, err, emax ;

  /*fixed m check 4.79*/
  emax = 0.0 ;
  for ( l = 0 ; l < L ; l ++ ) {
    for ( n = 0 ; n <= l ; n ++ ) {
      for ( m = -n ; m <= n ; m ++ ) {
	a1 = recursion_anm(n-1, m) ;
  	a2 = recursion_anm(n  , m) ;
  	a3 = recursion_anm(l  , m) ;
  	a4 = recursion_anm(l-1, m) ;
	coaxial_index(l, m, n-1, &i1, &sgn) ; a1 *= sgn ;
	coaxial_index(l, m, n+1, &i2, &sgn) ; a2 *= sgn ;
	coaxial_index(l+1, m, n, &i3, &sgn) ; a3 *= sgn ;
	coaxial_index(l-1, m, n, &i4, &sgn) ; a4 *= sgn ;
	err =	(a1*cfft[i1] - a2*cfft[i2]) -
	  (a3*cfft[i3] - a4*cfft[i4]) ;
	fprintf(stderr, "%2d %2d %2d %+e (%lg,%lg,%lg,%lg)\n",
		l, m, n, err,
		cfft[i1], cfft[i2],
		cfft[i3], cfft[i4]) ;
	emax = MAX(fabs(err), emax) ;
      }
    }
  }

  fprintf(stderr, "Maximum error in recursion relation (4.79): %e\n", emax) ;

  /*check on 4.80*/
  emax = 0.0 ;
  for ( l = 0 ; l < L ; l ++ ) {
    for ( n = 0 ; n < l ; n ++ ) {
      for ( m = -n+1 ; m <= n-1 ; m ++ ) {
	a1 = recursion_bnm(n  ,  m  ) ;
  	a2 = recursion_bnm(n+1, -m-1) ;
  	a3 = recursion_bnm(l+1,  m  ) ;
  	a4 = recursion_bnm(l  , -m-1) ;
	coaxial_index(l,   m+1, n-1, &i1, &sgn) ; a1 *= sgn ;
	coaxial_index(l,   m+1, n+1, &i2, &sgn) ; a2 *= sgn ;
	coaxial_index(l+1, m  , n  , &i3, &sgn) ; a3 *= sgn ;
	coaxial_index(l-1, m,   n  , &i4, &sgn) ; a4 *= sgn ;
	err = (a1*cfft[i1] - a2*cfft[i2]) -
	  (a3*cfft[i3] - a4*cfft[i4]) ;
	fprintf(stderr, "%2d %2d %2d %+8lg (%lg,%lg,%lg,%lg)\n",
		l, m, n, err,
		cfft[i1], cfft[i2],
		cfft[i3], cfft[i4]) ;
	emax = MAX(fabs(err), emax) ;
      }
    }
  }

  fprintf(stderr, "Maximum error in recursion relation (4.80): %e\n", emax) ;

  return 0 ;
}

#endif /*CHECK_COEFFICIENTS*/

WBFMM_REAL FUNCTION_NAME(recursion_anm)(gint n, gint m)

{
  m = ABS(m) ;

  if ( n < m ) return 0.0 ;

  return SQRT((WBFMM_REAL)(n+1+m)*(n+1-m)/(2*n+1)/(2*n+3)) ;
}

WBFMM_REAL FUNCTION_NAME(recursion_bnm)(gint n, gint m)

{
  /* g_assert(n >= 0) ; */
  if ( n < ABS(m) ) return 0.0 ;

  if ( m >= 0 ) return SQRT((WBFMM_REAL)(n-m-1)*(n-m)/(2*n-1)/(2*n+1)) ;

  g_assert((-n <= m) && (m < 0)) ;

  return -SQRT((WBFMM_REAL)(n-m-1)*(n-m)/(2*n-1)/(2*n+1)) ;
}

static void coefficient_recursions_coaxial(WBFMM_REAL *cfft, gint L, gint nc)

/*
  recursions from G&D for evaluation of coaxial translation
  coefficients; cfft should be initialized as required before function
  call; recursions are real and applied to nc components in cfft
*/

{
  gint l, m, n, i1, i2, i3, i4, i ;
  WBFMM_REAL a1, a2, a3, a4 ;

  /*G&D 4.79*/
  m = 0 ;
  /*fill (E|F)_{ln}^0*/
  for ( n = 0 ; n <= L ; n ++ ) {
    for ( l = n+1 ; l <= 2*L-n ; l ++ ) {
      i1 = wbfmm_coaxial_index_lmn(l,   m, n-1) ;
      i2 = wbfmm_coaxial_index_lmn(l,   m, n+1) ;
      i3 = wbfmm_coaxial_index_lmn(l+1, m, n  ) ;
      i4 = wbfmm_coaxial_index_lmn(l-1, m, n  ) ;
      a1 = FUNCTION_NAME(recursion_anm)(n-1, m) ;
      a2 = FUNCTION_NAME(recursion_anm)(n  , m) ;
      a3 = FUNCTION_NAME(recursion_anm)(l  , m) ;
      a4 = FUNCTION_NAME(recursion_anm)(l-1, m) ;
      for ( i = 0 ; i < nc ; i ++ ) 
	cfft[nc*i2+i] = 
	  (a1*cfft[nc*i1+i] - a3*cfft[nc*i3+i] + a4*cfft[nc*i4+i])/a2 ;
    }
  }

  /*G&D 4.84*/
  /*fill (E|F)_{l,m+1}^{m+1}*/
  for ( m = 0 ; m <= L ; m ++ ) {
    for ( l = m+1 ; l <= 2*L-m ; l ++ ) {
      a1 = FUNCTION_NAME(recursion_bnm)(m+1, -m-1) ;
      a2 = FUNCTION_NAME(recursion_bnm)(l  , -m-1) ;
      a3 = FUNCTION_NAME(recursion_bnm)(l+1,  m  ) ;
      i1 = wbfmm_coaxial_index_lmn(l  , m+1, m+1) ;
      i2 = wbfmm_coaxial_index_lmn(l-1, m  , m  ) ;
      i3 = wbfmm_coaxial_index_lmn(l+1, m  , m  ) ;
      for ( i = 0 ; i < nc ; i ++ ) 
	cfft[nc*i1+i] = (a2*cfft[nc*i2+i] - a3*cfft[nc*i3+i])/a1 ;
    }
  }

  for ( m = 1 ; m <= L ; m ++ ) {
    for ( n = m ; n <= L ; n ++ ) {
      for ( l = n+1 ; l <= 2*L-n ; l ++ ) {
	i1 = wbfmm_coaxial_index_lmn(l  , m, n-1) ;
	i2 = wbfmm_coaxial_index_lmn(l  , m, n+1) ;
	i3 = wbfmm_coaxial_index_lmn(l+1, m, n  ) ;
	i4 = wbfmm_coaxial_index_lmn(l-1, m, n  ) ;
	a1 = FUNCTION_NAME(recursion_anm)(n-1, m) ;
	a2 = FUNCTION_NAME(recursion_anm)(n  , m) ;
	a3 = FUNCTION_NAME(recursion_anm)(l  , m) ;
	a4 = FUNCTION_NAME(recursion_anm)(l-1, m) ;
	for ( i = 0 ; i < nc ; i ++ ) 
	  cfft[nc*i2+i] = 
	    (a1*cfft[nc*i1+i] - a3*cfft[nc*i3+i] + a4*cfft[nc*i4+i])/a2 ;
      }
    }
  }
  
  return ;
}

gint FUNCTION_NAME(wbfmm_coefficients_RR_coaxial)(WBFMM_REAL *cfftRR, gint L,
						  WBFMM_REAL kr, 
						  WBFMM_REAL *work)

/*
  generate coefficients for coaxial shift kr in positive z direction,
  G&D section 4.8

  indexing on coaxial coefficients using wbfmm_coaxial_index_lmn(l,m,n) 
  l >= n >= m >= 0 (no check on indexing)

  these are the (R|R) coefficients, which are identical to the (S|S)
  coefficients, G&D (4.62)
*/

{
  gint l, m, n, idx, sgnl ;
  WBFMM_REAL jlm1, jl, *cfft ;

  FUNCTION_NAME(wbfmm_bessel_j_init)(kr, &jlm1, &jl) ; 
  cfft = work ;

  /*G&D section 4.8.1*/
  /*G&D 4.83*/
  /*initialize (R|R)_{l0}^0*/
  /*no (-1)^l term as this reverses the sense of translation*/
  l = 0 ; m = 0 ; n = 0 ; sgnl = 1 ;
  idx = wbfmm_coaxial_index_lmn(l, m, n) ;
  cfft[idx] = sgnl*SQRT(2*l+1)*jlm1 ;
  l = 1 ; /* sgnl = -sgnl ; */
  idx = wbfmm_coaxial_index_lmn(l, m, n) ;
  cfft[idx] = sgnl*SQRT(2*l+1)*jl ;

  for ( l = 2 ; l <= 2*L ; l ++ ) {
    FUNCTION_NAME(wbfmm_bessel_j_recursion)(&jlm1, &jl, kr, l-1) ;
    /* sgnl = -sgnl ; */
    idx = wbfmm_coaxial_index_lmn(l, m, n) ;
    cfft[idx] = sgnl*SQRT(2*l+1)*jl ;
  }

  coefficient_recursions_coaxial(cfft, L, 1) ;

  /*copy to output array (probably not ideal, but better for development)*/
  memcpy(cfftRR, cfft, (L+1)*(L+2)*(L+3)/6*sizeof(WBFMM_REAL)) ;

#ifdef CHECK_COEFFICIENTS
  coaxial_coefficient_recursion_check(cfftRR, L) ;
#endif

  return 0 ;
}

gint FUNCTION_NAME(wbfmm_coefficients_SR_coaxial)(WBFMM_REAL *cfftSR, gint L,
						  WBFMM_REAL kr, 
						  WBFMM_REAL *work)

/*
  generate coefficients for coaxial shift kr in positive z direction,
  G&D section 4.8

  indexing on coaxial coefficients using wbfmm_coaxial_index_lmn(l,m,n) 
  l >= n >= m >= 0 (no check on indexing)

  these are the (S|R) coefficients, for singular to regular
  translations; note these are complex, with two REALs per coefficient
*/

{
  gint l, m, n, idx, sgnl ;
  WBFMM_REAL hlm1[2], hl[2], *cfft ;

  FUNCTION_NAME(wbfmm_bessel_h_init)(kr, hlm1, hl) ; 
  cfft = work ;

  /*G&D section 4.8.1*/
  /*G&D 4.83*/
  /*initialize (S|R)_{l0}^0*/
  /*no (-1)^l term as this reverses the sense of translation*/
  l = 0 ; m = 0 ; n = 0 ; sgnl = 1 ;
  idx = wbfmm_coaxial_index_lmn(l, m, n) ;
  cfft[2*idx+0] = sgnl*SQRT(2*l+1)*hlm1[0] ;
  cfft[2*idx+1] = sgnl*SQRT(2*l+1)*hlm1[1] ;
  l = 1 ; /* sgnl = -sgnl ; */
  idx = wbfmm_coaxial_index_lmn(l, m, n) ;
  cfft[2*idx+0] = sgnl*SQRT(2*l+1)*hl[0] ;
  cfft[2*idx+1] = sgnl*SQRT(2*l+1)*hl[1] ;

  for ( l = 2 ; l <= 2*L ; l ++ ) {
    FUNCTION_NAME(wbfmm_bessel_h_recursion)(hlm1, hl, kr, l-1) ;
    /* sgnl = -sgnl ; */
    idx = wbfmm_coaxial_index_lmn(l, m, n) ;
    cfft[2*idx+0] = sgnl*SQRT(2*l+1)*hl[0] ;
    cfft[2*idx+1] = sgnl*SQRT(2*l+1)*hl[1] ;
  }

  coefficient_recursions_coaxial(cfft, L, 2) ;

  /*copy to output array (probably not ideal, but better for development)*/
  memcpy(cfftSR, cfft, 2*(L+1)*(L+2)*(L+3)/6*sizeof(WBFMM_REAL)) ;

#ifdef CHECK_COEFFICIENTS
  coaxial_coefficient_recursion_check(cfftSR, L) ;
#endif

  return 0 ;
}

gint FUNCTION_NAME(wbfmm_coaxial_translate)(WBFMM_REAL *Co, gint cstro, 
					    gint No,
					    WBFMM_REAL *Ci, gint cstri,
					    gint Ni,
					    WBFMM_REAL *cfft, gint L,
					    gboolean complex)

/*
  apply coaxial translation cfft to input coefficients Ci, up to order
  Ni, accumulating output in Co, up to order No, G&D (4.76)

  array bounds and validity of inputs are not checked

  Co is not zeroed (to allow for accumulation in place)

  complex: TRUE for complex shift coefficients (e.g. S|R), FALSE for
  real (e.g. R|R)
*/

{
  gint l, m, n, idxi, idxc, sgn, sgnn, sgnm, offp, offm ;

  g_assert(L >= No) ;
  g_assert(L >= Ni) ;

  if ( !complex ) {
    sgnn = 1 ;
    for ( n = 0 ; n <= No ; n ++ ) {
      m = 0 ;
      offp = 2*wbfmm_coefficient_index_nm(n, m)*cstro ;
      sgn = sgnn ;
      for ( l = m ; l < n ; l ++ ) {
	idxi = wbfmm_coefficient_index_nm(l, m) ;
	idxc = wbfmm_coaxial_index_lmn(n,m,l) ;
	Co[offp+0] += sgn*cfft[idxc]*Ci[2*idxi*cstri+0] ;
	Co[offp+1] += sgn*cfft[idxc]*Ci[2*idxi*cstri+1] ;
	sgn = -sgn ;
      }
      sgn = 1 ;
      for ( l = n ; l <= Ni ; l ++ ) {
	idxi = wbfmm_coefficient_index_nm(l, m) ;
	idxc = wbfmm_coaxial_index_lmn(l,m,n) ;
	Co[offp+0] += sgn*cfft[idxc]*Ci[2*idxi*cstri+0] ;
	Co[offp+1] += sgn*cfft[idxc]*Ci[2*idxi*cstri+1] ;
      }

      sgnm = -sgnn ;
      for ( m = 1 ; m <= n ; m ++ ) {
	WBFMM_REAL buf[4] = {0.0} ;
	sgn = sgnm ;
	/*loop on input and coefficients*/
	for ( l = m ; l < n ; l ++ ) {
	  idxi = wbfmm_coefficient_index_nm(l, m) ;
	  idxc = wbfmm_coaxial_index_lmn(n,m,l) ;
	  buf[0] += sgn*cfft[idxc]*Ci[2*idxi*cstri+0] ;
	  buf[1] += sgn*cfft[idxc]*Ci[2*idxi*cstri+1] ;

	  idxi = wbfmm_coefficient_index_nm(l, -m) ;
	  idxc = wbfmm_coaxial_index_lmn(n,m,l) ;
	  buf[2] += sgn*cfft[idxc]*Ci[2*idxi*cstri+0] ;
	  buf[3] += sgn*cfft[idxc]*Ci[2*idxi*cstri+1] ;
	  sgn = -sgn ;
	}
	sgn = 1 ;
	for ( l = n ; l <= Ni ; l ++ ) {
	  idxi = wbfmm_coefficient_index_nm(l, m) ;
	  idxc = wbfmm_coaxial_index_lmn(l,m,n) ;
	  buf[0] += sgn*cfft[idxc]*Ci[2*idxi*cstri+0] ;
	  buf[1] += sgn*cfft[idxc]*Ci[2*idxi*cstri+1] ;

	  idxi = wbfmm_coefficient_index_nm(l, -m) ;
	  idxc = wbfmm_coaxial_index_lmn(l,m,n) ;
	  buf[2] += sgn*cfft[idxc]*Ci[2*idxi*cstri+0] ;
	  buf[3] += sgn*cfft[idxc]*Ci[2*idxi*cstri+1] ;
	}
	sgnm = -sgnm ;
	offp = 2*cstro*wbfmm_coefficient_index_nm(n, m) ;
	offm = 2*cstro*wbfmm_coefficient_index_nm(n, -m) ;
	Co[offp+0] += buf[0] ; Co[offp+1] += buf[1] ;
	Co[offm+0] += buf[2] ; Co[offm+1] += buf[3] ;
      }
      sgnn = -sgnn ;
    }
    return 0 ;
  }
  
  sgnn = 1 ;
  for ( n = 0 ; n <= No ; n ++ ) {
    m = 0 ; offp = 2*wbfmm_coefficient_index_nm(n, m)*cstro ;
    sgn = sgnn ;
    for ( l = m ; l < n ; l ++ ) {
      idxi = wbfmm_coefficient_index_nm(l, m) ;
      idxc = wbfmm_coaxial_index_lmn(n,m,l) ;
      Co[offp+0] += sgn*
	(cfft[2*idxc+0]*Ci[2*idxi*cstri+0] -
	 cfft[2*idxc+1]*Ci[2*idxi*cstri+1]) ;
      Co[offp+1] += sgn*
	(cfft[2*idxc+1]*Ci[2*idxi*cstri+0] +
	 cfft[2*idxc+0]*Ci[2*idxi*cstri+1]) ;
      sgn = -sgn ;
    }
    sgn = 1 ;
    for ( l = n ; l <= Ni ; l ++ ) {
      idxi = wbfmm_coefficient_index_nm(l, m) ;
      idxc = wbfmm_coaxial_index_lmn(l,m,n) ;
      Co[offp+0] += sgn*
	(cfft[2*idxc+0]*Ci[2*idxi*cstri+0] -
	 cfft[2*idxc+1]*Ci[2*idxi*cstri+1]) ;
      Co[offp+1] += sgn*
	(cfft[2*idxc+1]*Ci[2*idxi*cstri+0] +
	 cfft[2*idxc+0]*Ci[2*idxi*cstri+1]) ;
    }

    sgnm = -sgnn ;
    for ( m = 1 ; m <= n ; m ++ ) {
      WBFMM_REAL buf[4] = {0.0} ;
      sgn = sgnm ;
      /*loop on input and coefficients*/
      for ( l = m ; l < n ; l ++ ) {
	idxi = wbfmm_coefficient_index_nm(l, m) ;
	idxc = wbfmm_coaxial_index_lmn(n,m,l) ;
	buf[0] += sgn*
	  (cfft[2*idxc+0]*Ci[2*idxi*cstri+0] -
	   cfft[2*idxc+1]*Ci[2*idxi*cstri+1]) ;
	buf[1] += sgn*
	  (cfft[2*idxc+1]*Ci[2*idxi*cstri+0] +
	   cfft[2*idxc+0]*Ci[2*idxi*cstri+1]) ;
	
	idxi = wbfmm_coefficient_index_nm(l, -m) ;
	idxc = wbfmm_coaxial_index_lmn(n,m,l) ;
	buf[2] += sgn*
	  (cfft[2*idxc+0]*Ci[2*idxi*cstri+0] -
	   cfft[2*idxc+1]*Ci[2*idxi*cstri+1]) ;
	buf[3] += sgn*
	  (cfft[2*idxc+1]*Ci[2*idxi*cstri+0] +
	   cfft[2*idxc+0]*Ci[2*idxi*cstri+1]) ;
	sgn = -sgn ;
      }
      sgn = 1 ;
      for ( l = n ; l <= Ni ; l ++ ) {
	idxi = wbfmm_coefficient_index_nm(l, m) ;
	idxc = wbfmm_coaxial_index_lmn(l,m,n) ;
	buf[0] += sgn*
	  (cfft[2*idxc+0]*Ci[2*idxi*cstri+0] -
	   cfft[2*idxc+1]*Ci[2*idxi*cstri+1]) ;
	buf[1] += sgn*
	  (cfft[2*idxc+1]*Ci[2*idxi*cstri+0] +
	   cfft[2*idxc+0]*Ci[2*idxi*cstri+1]) ;
	
	idxi = wbfmm_coefficient_index_nm(l, -m) ;
	idxc = wbfmm_coaxial_index_lmn(l,m,n) ;
	buf[2] += sgn*
	  (cfft[2*idxc+0]*Ci[2*idxi*cstri+0] -
	   cfft[2*idxc+1]*Ci[2*idxi*cstri+1]) ;
	buf[3] += sgn*
	  (cfft[2*idxc+1]*Ci[2*idxi*cstri+0] +
	   cfft[2*idxc+0]*Ci[2*idxi*cstri+1]) ;
      }
      offp = 2*cstro*wbfmm_coefficient_index_nm(n,  m) ;
      offm = 2*cstro*wbfmm_coefficient_index_nm(n, -m) ;
      Co[offp+0] += buf[0] ; Co[offp+1] += buf[1] ;
      Co[offm+0] += buf[2] ; Co[offm+1] += buf[3] ;
      sgnm = -sgnm ;
    }
    sgnn = -sgnn ;
  }

  /* if ( !complex ) { */
  /*loop on output*/
  /* for ( n = 0 ; n <= No ; n ++ ) { */
  /*   for ( m = -n ; m <= n ; m ++ ) { */
  /* 	idxo = wbfmm_coefficient_index_nm(n, m) ; */
  /* 	/\* idxo = n*(n+1) + m ; *\/ */
  /* 	/\*loop on input and coefficients*\/ */
  /* 	for ( l = ABS(m) ; l <= Ni ; l ++ ) { */
  /* 	  /\* idxi = l*(l+1) + m ; *\/ */
  /* 	  idxi = wbfmm_coefficient_index_nm(l, m) ; */
  /* 	  idxc = wbfmm_coaxial_index(l, m, n) ; */
  /* 	  sgn  = wbfmm_coaxial_index_sgn(l, m, n) ; */
  /* 	  Co[2*idxo*cstro+0] += sgn*cfft[idxc]*Ci[2*idxi*cstri+0] ; */
  /* 	  Co[2*idxo*cstro+1] += sgn*cfft[idxc]*Ci[2*idxi*cstri+1] ; */
  /* 	} */
  /*   } */
  /* } */

  /* return 0 ;  } */

  /* for ( n = 0 ; n <= No ; n ++ ) { */
  /*   for ( m = -n ; m <= n ; m ++ ) { */
  /*     idxo = wbfmm_coefficient_index_nm(n, m) ; */
  /*     /\*loop on input and coefficients*\/ */
  /*     for ( l = ABS(m) ; l <= Ni ; l ++ ) { */
  /* 	idxi = wbfmm_coefficient_index_nm(l, m) ; */
  /* 	idxc = wbfmm_coaxial_index(l, m, n) ; */
  /* 	sgn  = wbfmm_coaxial_index_sgn(l, m, n) ; */
  /* 	Co[2*idxo*cstro+0] += sgn* */
  /* 	  (cfft[2*idxc+0]*Ci[2*idxi*cstri+0] - */
  /* 	   cfft[2*idxc+1]*Ci[2*idxi*cstri+1]) ; */
  /* 	Co[2*idxo*cstro+1] += sgn* */
  /* 	  (cfft[2*idxc+1]*Ci[2*idxi*cstri+0] + */
  /* 	   cfft[2*idxc+0]*Ci[2*idxi*cstri+1]) ; */
  /*     } */
  /*   } */

  return 0 ;
}
@


1.2
log
@*** empty log message ***
@
text
@d167 1
a167 1
void coefficient_recursions_coaxial(WBFMM_REAL *cfft, gint L, gint nc)
d361 1
a361 1
  gint l, m, n, idxi, idxo, idxc, sgn ;
d367 1
a367 1
    /*loop on output*/
d369 22
a390 2
      for ( m = -n ; m <= n ; m ++ ) {
	idxo = n*(n+1) + m ;
d392 11
a402 7
	for ( l = ABS(m) ; l <= Ni ; l ++ ) {
	  idxi = l*(l+1) + m ;
	  /* coaxial_index(l, m, n, &idxc, &sgn) ; */
	  idxc = wbfmm_coaxial_index(l, m, n) ;
	  sgn  = wbfmm_coaxial_index_sgn(l, m, n) ;
	  Co[2*idxo*cstro+0] += sgn*cfft[idxc]*Ci[2*idxi*cstri+0] ;
	  Co[2*idxo*cstro+1] += sgn*cfft[idxc]*Ci[2*idxi*cstri+1] ;
d404 17
d422 1
a423 1

d426 27
d454 4
a457 3
  for ( n = 0 ; n <= No ; n ++ ) {
    for ( m = -n ; m <= n ; m ++ ) {
      idxo = n*(n+1) + m ;
d459 39
a497 11
      for ( l = ABS(m) ; l <= Ni ; l ++ ) {
  	idxi = l*(l+1) + m ;
  	/* coaxial_index(l, m, n, &idxc, &sgn) ; */
  	idxc = wbfmm_coaxial_index(l, m, n) ;
  	sgn  = wbfmm_coaxial_index_sgn(l, m, n) ;
  	Co[2*idxo*cstro+0] += sgn*
  	  (cfft[2*idxc+0]*Ci[2*idxi*cstri+0] -
  	   cfft[2*idxc+1]*Ci[2*idxi*cstri+1]) ;
  	Co[2*idxo*cstro+1] += sgn*
  	  (cfft[2*idxc+1]*Ci[2*idxi*cstri+0] +
  	   cfft[2*idxc+0]*Ci[2*idxi*cstri+1]) ;
d499 5
d505 1
d507 37
@


1.1
log
@Initial revision
@
text
@a38 2
#define coaxial_index_lmn(_l,_m,_n)			\
  ((_l)*((_l)+1)*((_l)+2)/6 + (_n)*((_n)+1)/2 + (_m))
d47 1
a47 1
gint coaxial_index(gint l, gint m, gint n, gint *idx, gint *sgn) ;
d51 31
a81 1
static gint coaxial_coefficient_recursion_checkRR(WBFMM_REAL *cfft, gint L)
d84 1
a84 1
  gint l, m, n, idx1, idx2, idx3, idx4, sgn ;
d96 6
a101 6
	coaxial_index(l, m, n-1, &idx1, &sgn) ; a1 *= sgn ;
	coaxial_index(l, m, n+1, &idx2, &sgn) ; a2 *= sgn ;
	coaxial_index(l+1, m, n, &idx3, &sgn) ; a3 *= sgn ;
	coaxial_index(l-1, m, n, &idx4, &sgn) ; a4 *= sgn ;
	err =	(a1*cfft[idx1] - a2*cfft[idx2]) -
	  (a3*cfft[idx3] - a4*cfft[idx4]) ;
d104 2
a105 2
		cfft[idx1], cfft[idx2],
		cfft[idx3], cfft[idx4]) ;
d122 6
a127 6
	coaxial_index(l,   m+1, n-1, &idx1, &sgn) ; a1 *= sgn ;
	coaxial_index(l,   m+1, n+1, &idx2, &sgn) ; a2 *= sgn ;
	coaxial_index(l+1, m  , n  , &idx3, &sgn) ; a3 *= sgn ;
	coaxial_index(l-1, m,   n  , &idx4, &sgn) ; a4 *= sgn ;
	err = (a1*cfft[idx1] - a2*cfft[idx2]) -
	  (a3*cfft[idx3] - a4*cfft[idx4]) ;
d130 2
a131 2
		cfft[idx1], cfft[idx2],
		cfft[idx3], cfft[idx4]) ;
d167 1
a167 1
gint coaxial_index(gint l, gint m, gint n, gint *idx, gint *sgn)
d170 3
a172 6
  generate the index into the coefficient matrix for general l,m,n,

  l >= 0, n >= 0, -n <= m <= n

  sgn is the sign multiplier for the coefficient, i.e. use
  sgn*cfft[idx] (see G&D, 4.82)
d176 2
a177 1
  m = ABS(m) ;
d179 18
a196 1
  if ( m > n ) { *idx = *sgn = 0 ; return 0 ; }
d198 13
a210 5
  if ( l >= n ) {
    *idx = coaxial_index_lmn(l, m, n) ;
    *sgn = 1 ;
    g_assert(*idx >= 0) ;
    return 0 ;
d213 19
a231 5
  *idx = coaxial_index_lmn(n, m, l) ;
  *sgn = minus_one_pow(n+l) ;
  g_assert(*idx >= 0) ;

  return 0 ;
d234 3
a236 2
gint FUNCTION_NAME(coefficients_RR_coaxial)(WBFMM_REAL *cfftRR, gint L,
					    WBFMM_REAL kr, WBFMM_REAL *work)
d242 1
a242 1
  indexing on coaxial coefficients using coaxial_index_lmn(l,m,n) 
d250 2
a251 2
  gint l, m, n, idx, sgnl, idx1, idx2, idx3, idx4 ;
  WBFMM_REAL jlm1, jl, a1, a2, a3, a4, *cfft ;
d258 1
a258 1
  /*fill (R|R)_{l0}^0*/
d261 1
a261 1
  idx = coaxial_index_lmn(l, m, n) ;
d264 1
a264 1
  idx = coaxial_index_lmn(l, m, n) ;
d270 1
a270 1
    idx = coaxial_index_lmn(l, m, n) ;
d274 46
a319 16
  /*G&D 4.79*/
  m = 0 ;
  /*fill (R|R)_{ln}^0*/
  for ( n = 0 ; n <= L ; n ++ ) {
    for ( l = n+1 ; l <= 2*L-n ; l ++ ) {
      idx1 = coaxial_index_lmn(l,   m, n-1) ;
      idx2 = coaxial_index_lmn(l,   m, n+1) ;
      idx3 = coaxial_index_lmn(l+1, m, n  ) ;
      idx4 = coaxial_index_lmn(l-1, m, n  ) ;
      a1 = FUNCTION_NAME(recursion_anm)(n-1, m) ;
      a2 = FUNCTION_NAME(recursion_anm)(n  , m) ;
      a3 = FUNCTION_NAME(recursion_anm)(l  , m) ;
      a4 = FUNCTION_NAME(recursion_anm)(l-1, m) ;
      cfft[idx2] = (a1*cfft[idx1] - a3*cfft[idx3] + a4*cfft[idx4])/a2 ;
    }
  }
d321 6
a326 12
  /*G&D 4.84*/
  /*fill (R|R)_{l,m+1}^{m+1}*/
  for ( m = 0 ; m <= L ; m ++ ) {
    for ( l = m+1 ; l <= 2*L-m ; l ++ ) {
      a1 = FUNCTION_NAME(recursion_bnm)(m+1, -m-1) ;
      a2 = FUNCTION_NAME(recursion_bnm)(l  , -m-1) ;
      a3 = FUNCTION_NAME(recursion_bnm)(l+1,  m  ) ;
      idx1 = coaxial_index_lmn(l  , m+1, m+1) ;
      idx2 = coaxial_index_lmn(l-1, m  , m  ) ;
      idx3 = coaxial_index_lmn(l+1, m  , m  ) ;
      cfft[idx1] = (a2*cfft[idx2] - a3*cfft[idx3])/a1 ;
    }
d329 1
a329 15
  for ( m = 1 ; m <= L ; m ++ ) {
    for ( n = m ; n <= L ; n ++ ) {
      for ( l = n+1 ; l <= 2*L-n ; l ++ ) {
	idx1 = coaxial_index_lmn(l,   m, n-1) ;
	idx2 = coaxial_index_lmn(l,   m, n+1) ;
	idx3 = coaxial_index_lmn(l+1, m, n  ) ;
	idx4 = coaxial_index_lmn(l-1, m, n  ) ;
	a1 = FUNCTION_NAME(recursion_anm)(n-1, m) ;
	a2 = FUNCTION_NAME(recursion_anm)(n  , m) ;
	a3 = FUNCTION_NAME(recursion_anm)(l  , m) ;
	a4 = FUNCTION_NAME(recursion_anm)(l-1, m) ;
	cfft[idx2] = (a1*cfft[idx1] - a3*cfft[idx3] + a4*cfft[idx4])/a2 ;
      }
    }
  }
d331 2
a332 3
  /*copy to output array (probably not ideal, but better for
    development)*/
  memcpy(cfftRR, cfft, (L+1)*(L+2)*(L+3)/6*sizeof(WBFMM_REAL)) ;
d335 1
a335 1
  coaxial_coefficient_recursion_checkRR(cfftRR, L) ;
d345 2
a346 1
					    WBFMM_REAL *cfftRR, gint L)
d349 2
a350 2
  apply coaxial translation cfftRR to input coefficients Ci, up to
  order Ni, accumulating output in Co, up to order No, G&D (4.76)
d355 3
d366 20
a385 1
  /*loop on output*/
d391 10
a400 4
	idxi = l*(l+1) + m ;
	coaxial_index(l, m, n, &idxc, &sgn) ;
	Co[2*idxo*cstro+0] += sgn*cfftRR[idxc]*Ci[2*idxi*cstri+0] ;
	Co[2*idxo*cstro+1] += sgn*cfftRR[idxc]*Ci[2*idxi*cstri+1] ;
@
