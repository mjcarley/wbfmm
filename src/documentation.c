/*
 * Autogenerated file, do not  edit
 * Mon Mar 30 15:29:27 BST 2020
 * -------------------------------
 */


/** 
 * @ingroup boxes
 *
 * @brief Add points to an octree
 *
 * Add a set of source points to an octree. The points are assumed to
 * be in an array of real values with components in a packed triple,
 * indexed using a stride of pstr bytes (this allows for quite general
 * handling of different source formats). 
 * 
 * @param t an existing ::wbfmm_tree_t;
 * @param pts an array containing point coordinates;
 * @param npts the number of points in \a pts;
 * @param pstr stride between points in bytes.
 * 
 * @return 0 on success.
 */

gint wbfmm_tree_add_points(wbfmm_tree_t *t, 
						gpointer pts, guint npts,
						gsize pstr) {}

/** 
 * @ingroup rotations
 * @brief Compute the rotation angles \f$(\theta,\phi,\chi)\f$ between axes
 *
 * Compute the angles for rotation between two systems of axes 
 * \f$(\mathbf{i}_{x}, \mathbf{i}_{y}, \mathbf{i}_{z})\f$ and
 * \f$(\mathbf{j}_{x}, \mathbf{j}_{y}, \mathbf{j}_{z})\f$, as
 *  defined in Section 5 of Gumerov and Duraiswami. All vectors
 * should be unit length and form a right-handed coordinate system 
 * (no check is performed).
 * 
 * @param ix initial coordinate system \f$x\f$ axis;
 * @param iy initial coordinate system \f$y\f$ axis;
 * @param iz initial coordinate system \f$z\f$ axis;
 * @param jx rotated coordinate system \f$x\f$ axis;
 * @param jy rotated coordinate system \f$y\f$ axis;
 * @param jz rotated coordinate system \f$z\f$ axis;
 * @param th on exit, \f$\theta\f$ for rotation;
 * @param ph on exit, \f$\phi\f$ for rotation;
 * @param ch on exit, \f$\chi\f$ for rotation.
 * 
 * @return 0 on success
 */

gint wbfmm_rotation_angles(gdouble *ix, gdouble *iy,
						gdouble *iz, gdouble *jx,
						gdouble *jy, gdouble *jz,
						gdouble *th, gdouble *ph,
						gdouble *ch) {}

/**
 * @ingroup rotations
 * @brief Compute rotation coefficients for angle \f$\theta\f$
 *
 * Generate the coefficients required to rotate one multipole
 * expansion to a new orientation, using Gumerov and Duraiswami,
 * Section 5, equation (5.48) and recursion (5.55). Coefficients \a H
 * are real and densely packed on output.
 *
 * @param H on output rotation coefficients;
 * @param N maximum order of coefficients to compute;
 * @param th rotation angle \f$\theta\f$, from 
 * ::wbfmm_rotation_angles(...);
 * @param work workspace
 *
 * @return 0 on success
 */
 gint wbfmm_coefficients_H_rotation(gdouble *H,
							 gint N, gdouble th,
							 gdouble *work) {}
 
/**
 * @ingroup rotations
 * @brief Apply rotation \f$(\theta,\phi\,\chi)\f$ to multipole
 * coefficients
 * 
 * Given the rotation coefficients \a H for angle \f$\theta\f$ from 
 * ::wbfmm_coefficients_H_rotation(...), rotate input
 * coefficients to new system of axes, using \a H and angles
 * \f$\phi\f$ and \f$\chi\f$. Input and output are strided arrays of
 * dense complex data with spacing between adjacent complex values
 * given as \a cstri and \a cstro elements respectively. Thus, \a Co for
 * example is packed as:
 *
 * \f$[\Re(C_{00})\quad \Im(C_{00}) \ldots (2\times\mbox{cstro})
 * \ldots \Re(C_{0,-1})\quad \Im(C_{0,-1})]\f$
 *
 * This stride system allows for packing data more conveniently for
 * upward and downward passes in the FMM proper. 
 *
 * The function is available as a reference version
 * wbfmm_rotate_H_ref(...) and an optimized version
 * wbfmm_rotate_H_avx(...) which uses AVX
 * optimizations if available. The compile time switch -DWBFMM_USE_AVX
 * selects the AVX version. 
 *
 * @param Co on output contains rotated coefficients;
 * @param cstro stride in \a Co, in number of complex elements;
 * @param Ci input coefficients, to be rotated;
 * @param cstri stride in \a Ci, in number of complex elements;
 * @param N maximum order of coefficients;
 * @param nq number of source components;
 * @param H rotation coefficients for angle \f$\theta\f$, from
 * ::wbfmm_coefficients_H_rotation(...);
 * @param ph angle \f$\phi\f$ for rotation;
 * @param ch angle \f$\chi\f$ for rotation.
 *
 * @return 0 on success
 */

gint wbfmm_rotate_H(gdouble *Co, gint cstro,
					 gdouble *Ci, gint cstri,
					 gint N, gint nq,
					 gdouble *H, gdouble ph,
					 gdouble ch) {}

/**     
 * @fn gint wbfmm_coefficients_RR_coaxial(gdouble
 * *cfftRR, gint L, gdouble kr, gdouble *work)
 *
 * @ingroup translations
 *
 * @brief Generate coefficients for coaxial regular-to-regular translation
 *
 * Generate translation coefficients for a regular-to-regular coaxial
 * shift along the \f$z\f$ axis of the local coordinate system, by
 * distance \f$r\f$ for wavenumber \f$k\f$, using the methods of
 * Section 4.8 of Gumerov and Duraiswami. The regular-to-regular
 * translation coefficients are identical to the singular-to-singular
 * coefficients and are real.
 *
 * @param cfftRR on output contains (real) translation coefficients;
 * @param L maximum order of multipole expansion to be translated;
 * @param kr coaxial translation parameter (wavenumber times distance);
 * @param work workspace
 * 
 * @return 0 on success
 */


/**
 *
 * @ingroup translations
 *
 * @brief Generate coefficients for coaxial singular-to-regular translation
 *
 * Generate translation coefficients for a singular-to-regular coaxial
 * shift along the \f$z\f$ axis of the local coordinate system, by
 * distance \f$r\f$ for wavenumber \f$k\f$, using the methods of
 * Section 4.8 of Gumerov and Duraiswami. The output coefficients are
 * complex.
 *
 * @param cfftSR on output contains (complex) translation coefficients;
 * @param L maximum order of multipole expansion to be translated;
 * @param kr coaxial translation parameter (wavenumber times distance);
 * @param work workspace
 *
 * @return 0 on success
 */

gint wbfmm_coefficients_SR_coaxial(gdouble *cfftSR, 
							gint L, gdouble kr,
							gdouble *work) {}


/**
 *
 * @ingroup translations
 *
 * @brief Perform coaxial translation of multipole expansion
 *
 * Compute the coaxial translation of a multipole expansion along its
 * \f$z\f$ axis, using coefficients from
 * ::wbfmm_coefficients_SR_coaxial(...) (complex) or
 * ::wbfmm_coefficients_RR_coaxial(...) (real). Input
 * and output coefficients are strided data as described for
 * ::wbfmm_rotate_H(...).
 *
 * @param Co on output contains translated multipole expansion;
 * @param cstro stride for output data in number of complex elements;
 * @param No order of output expansion;
 * @param Ci input multipole expansion;
 * @param cstri stride for input data in number of complex elements;
 * @param Ni order of input expansion;
 * @param cfft translation coefficients;
 * @param L maximum order of translation coefficients;
 * @param complex if TRUE treat \a cfft as complex
 * (e.g. for singular-to-regular translation); if FALSE treat as real
 * (e.g. regular-to-regular or singular-to-singular).
 *
 * @return 0 on success
 */
 gint wbfmm_coaxial_translate(gdouble *Co,
						   gint cstro, gint No,
						   gdouble *Ci,
						   gint cstri, gint Ni,
						   gdouble *cfft,
						   gint L, gboolean complex) {}
 
/**
 *
 * @ingroup boxes
 *
 * @brief Allocate a new octree
 *
 * @param x location of origin of tree;
 * @param D width of domain;
 * @param maxpoints maximum number of source points in tree.
 *
 * @return pointer to newly allocated tree.
 */
 wbfmm_tree_t *wbfmm_tree_new(gdouble *x,
						   gdouble D,
						   guint maxpoints) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Generate leaf expansions for a tree
 *
 * Generate leaf expansions for a tree given some combination of
 * monopole and dipole sources. Source positions are those in the
 * point list attached to the tree using
 * ::wbfmm_tree_add_points(...) and indexing in the
 * array must correspond to that in the point list. Input arrays may
 * be NULL: if \a src is not NULL, it is interpreted as a list of
 * complex monopole strengths; if \a normals is not NULL, \a dipoles
 * may not be NULL and they are interpreted respectively as a vector
 * (`normal') at each source position and a scalar complex amplitude
 * (this corresponds to surface normal and a normal velocity amplitude
 * in a boundary element method calculation); if \a normals is NULL
 * and \a dipoles is not NULL, \a dipoles is interpreted as a
 * three-element complex vector specifying the dipole strength. The
 * strides \a sstr, \a nstr, and \a dstr are the number of scalar
 * elements between successive entries in the arrays, with the
 * elements of each entry densely packed. For example, a list of
 * normals might read:
 *
 * \f$[n_{x1}\quad n_{y1}\quad n_{z1}\quad a_{1}\quad b_{1}\quad n_{x2}
 * \ldots]\f$
 *
 * where \f$(n_{x1},n_{y1},n_{z1})\f$ is the first normal vector and
 * \f$a_{1}\f$ and \f$b_{1}\f$ are arbitrary entries in the array. In
 * this case, the stride \a nstr would be 5, the number of elements
 * between successive values of \f$n_{xi}\f$. 
 *
 * @param t octree for problem;
 * @param k wavenumber;
 * @param src monopole source strengths;
 * @param sstr stride of data in \a src;
 * @param normals dipole normals;
 * @param nstr stride of data in \a normals;
 * @param dipoles dipole source strengths (if \a normals is not NULL), or 
 * moment vectors (if \a normals is NULL);
 * @param dstr stride of data in \a dipoles;
 * @param zero_expansions if TRUE, set expansion coefficients to zero
 * before adding source terms;
 * @param work workspace.
 *
 * @return 0 on success
 */

 gint wbfmm_tree_leaf_expansions(wbfmm_tree_t *t,
						      gdouble k,
						      gdouble *src,
						      gint sstr, 
						      gdouble *normals,
						      gint nstr,
						      gdouble *dipoles,
						      gint dstr,
						      gboolean zero_expansions,
						      gdouble *work) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Evaluate singular expansion about a box centre
 *
 * @param t octree for problem;
 * @param level level in \a t;
 * @param b index of box at level \a level of \a t; 
 * @param k wavenumber;
 * @param x field evaluation point;
 * @param f on output field at \a x (not zeroed before evaluation);
 * @param fstr stride in \a field in number of array entries;
 * @param work workspace
 *
 * @return 0 on success
 */

 gint wbfmm_tree_box_field(wbfmm_tree_t *t, guint
						level, guint b, gdouble k,
						gdouble *x, gdouble *f,
						gint fstr,
						gdouble *work) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Evaluate local field from regular expansion in box
 *
 * @param t octree for domain;
 * @param level level of \a t;
 * @param b box index at level \a level of \a t;
 * @param k wavenumber;
 * @param x location of evaluation point;
 * @param f on output, field value (not zeroed before evaluation);
 * @param fstr stride of data in \a f;
 * @param src source strengths;
 * @param sstr stride of data in \a src;
 * @param eval_neighbours if TRUE compute contributions from sources 
 * in box \a b and neighbours; 
 * @param field XOR combination of ::wbfmm_field_t to select output 
 * field type (scalar, gradient, curl, etc.);
 * @param work workspace.
 *
 * @return 0 on success
 */

 gint wbfmm_tree_box_local_field(wbfmm_tree_t *t,
						      guint level,
						      guint b, gdouble k,
						      gdouble *x,
						      gdouble *f,
						      gint fstr,
						      gdouble *src,
						      gint sstr,
						      gboolean eval_neighbours,
						      guint field,
						      gdouble *work) {}


/**
 *
 * @ingroup boxes
 *
 * @brief Find Morton index for point in a cubic domain
 *
 * @param x point in space (three components, densely packed);
 * @param c location of bottom left corner of domain;
 * @param D width of domain.
 *
 * @return 0 on success
 */

 guint64 wbfmm_point_index_3d(gdouble *x,
						   gdouble *c,
						   gdouble D) {}

/**
 *
 * @ingroup boxes 
 *
 * @brief Initialize expansion coefficient data in an octree
 *
 * @param t octree for problem;
 * @param l level to initialize data for;
 * @param nr order of regular expansions at level \a l;
 * @param ns order of singular expansions at level \a l.
 *
 * @return 0 on success
 */

gint wbfmm_tree_coefficient_init(wbfmm_tree_t
						      *t, guint l, guint nr,
						      guint ns) {}

/** 
 *
 * @ingroup boxes
 *
 * @brief
 *
 * Refine an existing octree by adding a level and redistributing
 * points attached to the tree to the boxes at the new level.
 * 
 * @param t an existing ::wbfmm_tree_t.
 * 
 * @return 0 on success.
 */

gint wbfmm_tree_refine(wbfmm_tree_t *t) {}

/**
 *
 * @ingroup shift
 *
 * @brief Upward shift of singular expansion from eight children to 
 * common parent
 *
 * Shift the expansion of eight child boxes to their parent and sum
 * into the parent expansion. This function assumes data are packed
 * with a stride of eight elements so that all expansion coefficients
 * of a given order are contiguous in memory, ordered by Morton index. 
 *
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param H47 rotation coefficients for `upper' children (Morton index 4-7);
 * @param Lh maximum order of rotation coefficients;
 * @param trans coaxial translation operator for distance between child and 
 * parent box centres;
 * @param Ls order of \a trans;
 * @param nq number of source components;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_child_parent_shift(gdouble *Cp, gint Np,
						   gdouble *Cc, gint Nc,
						   gdouble *H03, 
						   gdouble *H47, gint Lh,
						   gdouble *trans, gint Ls,
						   gint nq,
						   gdouble *work) {}

/**
 *
 * @ingroup shift
 *
 * @brief Upward shift of singular expansion from eight children to 
 * common parent, using backward translations
 *
 * Shift the expansion of eight child boxes to their parent and sum
 * into the parent expansion. This function assumes data are packed
 * with a stride of eight elements so that all expansion coefficients
 * of a given order are contiguous in memory, ordered by Morton
 * index. The method is the same as for
 * ::wbfmm_child_parent_shift(...), except that
 * the child boxes with Morton indices 4-7 are rotated in the same
 * sense as the diagonally opposite child boxes 0-3 and a reverse
 * (negative distance) coaxial translation is used to combine them
 * with the lower child box data with the same rotation. The reverse
 * rotation is then applied to the summed data meaning that only four
 * reverse rotations rather than eight are required to transfer the
 * data to the parent box orientation.
 *
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param Lh maximum order of rotation coefficients;
 * @param transf forward (\f$+kr\f$) coaxial translation operator for 
 * distance between child and parent box centres;
 * @param transb backward (\f$-kr\f$) coaxial translation operator for 
 * distance between child and parent box centres;
 * @param Ls order of \a trans;
 * @param work workspace
 *
 * @return 0 on success
 *
 */


gint wbfmm_child_parent_shift_bw(gdouble *Cp, gint Np,
						      gdouble *Cc, gint Nc,
						      gdouble *H03, gint Lh,
						      gdouble *transf,
						      gdouble *transb,
						      gint Ls,
						      gdouble *work) {}

/**
 *
 * @ingroup shift
 *
 * @brief Downward shift of parent expansion to child box centres
 *
 * Shift the (regular) expansion data from a parent box to each of its
 * child boxes, assuming the same packing as in
 * ::wbfmm_child_parent_shift(...). Note that the
 * rotation matrices for this function are switched relative to the
 * rotations of the same name in
 * ::wbfmm_child_parent_shift(...), because the `upper'
 * children rotate `down' to be shifted to the parent centre but the
 * rotation is `up' to shift from the parent to those children, and
 * similarly for the `lower' children.
 *
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param H47 rotation coefficients for `upper' children (Morton index 4-7);
 * @param Lh maximum order of rotation coefficients;
 * @param trans coaxial translation operator for distance between child and 
 * parent box centres;
 * @param Ls order of \a trans;
 * @param nq number of source components;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

  gint wbfmm_parent_child_shift(gdouble *Cc, gint Nc,
						   gdouble *Cp, gint Np,
						   gdouble *H03, 
						   gdouble *H47, gint Lh,
						   gdouble *trans, gint Ls,
						   gint nq,
						   gdouble *work) {}

/**
 * @ingroup shift
 *
 * @brief Extract the rotation angles for boxes on interaction list 4
 *
 * Find the rotation angles \f$(\theta,\phi\,\chi)\f$ between a box at
 * integer coordinates \f$(i,j,k)\f$, using a look-up table which
 * should be initialized with
 * ::wbfmm_shift_angle_table_init(...)
 *
 * @param i integer \f$x\f$ coordinate of box on interaction list;
 * @param j integer \f$y\f$ coordinate of box on interaction list;
 * @param k integer \f$z\f$ coordinate of box on interaction list;
 * @param th \f$\theta\f$ for rotation between boxes;
 * @param ph \f$\phi\f$ for rotation between boxes;
 * @param ch \f$\chi\f$ for rotation between boxes;
 * @param rs scaling factor for distance between box centres, distance
 * is \a rs multiplied by box width.
 *
 * @return 0 on success
 *
 */

 gint wbfmm_shift_angles_list4(gint i, gint j, gint k,
					     gdouble *th, gdouble *ph,
					     gdouble *ch, gdouble *rs) {} 

/**
 *
 * @ingroup shift
 *
 * @brief Initialize table of angles for shift operations
 *
 * This function must be called before any interaction calculations
 * are performed, in particular before any call to
 * ::wbfmm_shift_operators_new(...), in order to
 * initialize the look-up table of orientations between boxes in
 * interaction lists.
 *
 *
 * @return 0 on success
 *
 */

gint wbfmm_shift_angle_table_init(void) {}
 
/**
 *
 * @ingroup shift 
 *
 * @brief Allocate shift operators and initialize rotations
 *
 * Allocate a new ::wbfmm_shift_operators_t of given maximum order and
 * initialize the rotation coefficients needed for same-level
 * interaction calculations and upward and downward passes.
 *
 * @param L maximum order of expansions;
 * @param bw if TRUE generate operators for backward translation algorithm;
 * @param work workspace.
 *
 * @return 0 on success
 *
 */

wbfmm_shift_operators_t
*wbfmm_shift_operators_new(guint L,
						gboolean bw,
						gdouble *work) {}

/**
 *
 * @ingroup shift
 *
 * @brief Initialize singular-to-regular translation operators
 *
 * @param w a ::wbfmm_shift_operators_t allocated with 
 * wbfmm_shift_operators_new(...);
 * @param D width of the problem domain;
 * @param level level for which to generate translations;
 * @param L order of translations;
 * @param k wavenumber;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_shift_operators_coaxial_SR_init)
     (wbfmm_shift_operators_t *w, gdouble D, guint level, guint L,
      gdouble k, gdouble *work) {}

/**
 *
 * @ingroup shift
 *
 * @brief Initialize singular-to-singular (regular-to-regular)
 * translation operators
 *
 * @param w a ::wbfmm_shift_operators_t allocated with 
 * wbfmm_shift_operators_new(...);
 * @param D width of the problem domain;
 * @param level level for which to generate translations;
 * @param L order of translations;
 * @param k wavenumber;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

 gint wbfmm_shift_operators_coaxial_SS_init)
     (wbfmm_shift_operators_t *w, gdouble D, guint level, 
      guint L, gdouble k, gdouble *work) {}

 /**
 *
 * @ingroup expansions
 *
 * @brief Generation of singular expansion coefficients for point source
 *
 * @param k wavenumber;
 * @param N order of expansion;
 * @param x0 centre of expansion;
 * @param xs source position;
 * @param q complex source strength;
 * @param nq number of source elements;
 * @param cfft incremented with expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

 gint wbfmm_expansion_h_cfft(gdouble k, gint N, 
                                                  gdouble *x0,
						  gdouble *xs,
						  gdouble *q, gint nq,
						  gdouble *cfft, gint cstr,
						  gdouble *work) {}

 /**
 *
 * @ingroup expansions
 *
 * @brief Generation of singular expansion coefficients for point dipole source
 *
 * @param k wavenumber;
 * @param N order of expansion;
 * @param x0 centre of expansion;
 * @param xs source position;
 * @param fx component of complex source strength;
 * @param fy component of complex source strength;
 * @param fz component of complex source strength;
 * @param nq number of source elements;
 * @param cfft incremented with expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

 gint wbfmm_expansion_dipole_h_cfft(gdouble k, gint N, 
							 gdouble *x0,
							 gdouble *xs,
							 gdouble *fx,
							 gdouble *fy,
							 gdouble *fz,
							 gint nq,
							 gdouble *cfft,
							 gint cstr,
							 gdouble *work) {}


 /**
 *
 * @ingroup expansions
 *
 * @brief Generation of singular expansion coefficients for point
 * dipole source defined as normal and strength
 *
 * @param k wavenumber;
 * @param N order of expansion;
 * @param x0 centre of expansion;
 * @param xs source position;
 * @param normal normal vector for source orientation;
 * @param q complex source strength;
 * @param nq number of source elements;
 * @param cfft incremented with expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param nq number of source elements;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_expansion_normal_h_cfft(gdouble k, gint N, 
							gdouble *x0,
							gdouble *xs,
							gdouble *normal,
							gdouble *q,
							gint nq,
							gdouble *cfft,
							gint cstr,
							gdouble *work) ;

/**
 *
 * @ingroup expansions
 *
 * @brief Evaluate a singular expansion
 *
 * @param k wavenumber;
 * @param x0 centre of expansion;
 * @param cfft expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param nq number of source elements;
 * @param N order of expansion;
 * @param xf field point;
 * @param field incremented with computed field;
 * @param fstr stride in \a field, in number of array entries;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_expansion_h_evaluate(gdouble k, 
						     gdouble *x0,
						     gdouble *cfft,
						     gint cstr,
						     gint N, 
						     gint nq,
						     gdouble *xf, 
						     gdouble *field,
						     gint fstr,
						     gdouble *work) {}

/**
 *
 * @ingroup expansions
 *
 * @brief Evaluate the gradient of a singular expansion
 *
 * @param k wavenumber;
 * @param x0 centre of expansion;
 * @param cfft expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param N order of expansion;
 * @param nq number of source elements;
 * @param xf field point;
 * @param field incremented with computed gradient;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_expansion_h_grad_evaluate(gdouble k, 
							  gdouble *x0,
							  gdouble *cfft,
							  gint cstr,
							  gint N, 
							  gint nq,
							  gdouble *xf, 
							  gdouble *field,
							  gdouble *work) {}


/**
 *
 * @ingroup expansions
 *
 * @brief Evaluate the gradient of a regular expansion
 *
 * @param k wavenumber;
 * @param x0 centre of expansion;
 * @param cfft expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param N order of expansion;
 * @param nq number of source elements;
 * @param xf field point;
 * @param field incremented with computed gradient;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_expansion_j_grad_evaluate(gdouble k,
							  gdouble *x0,
							  gdouble *cfft,
							  gint cstr,
							  gint N, 
							  gint nq,
							  gdouble *xf, 
							  gdouble *field,
							  gint fstr,
							  gdouble *work) ;

/**
 *
 * @ingroup expansions
 *
 * @brief Evaluate a regular expansion
 *
 * @param k wavenumber;
 * @param x0 centre of expansion;
 * @param cfft expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param nq number of source elements;
 * @param N order of expansion;
 * @param xf field point;
 * @param field incremented with computed field;
 * @param fstr stride in \a field in number of array entries;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

 gint wbfmm_expansion_j_evaluate(gdouble k,
                                                      gdouble *x0,
						      gdouble *cfft,
						      gint cstr, gint nq,
						      gint N, 
						      gdouble *xf, 
						      gdouble *field,
						      gint fstr, 
						      gdouble *work) {}

 /**
 *
 * @ingroup pass
 *
 * @brief Perform downward pass at one level of an octree
 *
 * Perform one stage of a downward pass for tree levels greater than
 * or equal to two. The actions performed are the evaluation of the
 * list 4 contribution to the regular expansion and, for non-leaf
 * boxes, a downward shift of the regular expansions to the child
 * boxes at the next level.
 *
 * @param t an initialized octree which has had the upward pass performed;
 * @param op shift operators allocated for \a t;
 * @param level level at which to perform downward pass;
 * @param work workspace
 *
 * @return 0 on success
 *
 */
 gint wbfmm_downward_pass(wbfmm_tree_t *t,
					       wbfmm_shift_operators_t *op,
					       guint level, gdouble *work) {}

/**
 *
 * @ingroup pass
 *
 * @brief Perform upward pass at one level of an octree
 *
 * Perform one stage of the upward pass in an octree. The action
 * performed is the upward shift of the singular expansions from boxes
 * at level \a level to their parents. 
 *
 * @param t an initialized octree;
 * @param op shift operators allocated for \a t;
 * @param level level at which to perform upward pass;
 * @param work workspace
 *
 * @return 0 on success
 *
 */
 gint wbfmm_upward_pass(wbfmm_tree_t *t,
					     wbfmm_shift_operators_t *op,
					     guint level, gdouble *work) {}

/**
 *
 * @ingroup util
 *
 * @brief Convert Cartesian to spherical coordinates \f$(r,\theta,\phi)\f$
 *
 * @param x0 centre of coordinate system;
 * @param x point whose coordinates are to be found;
 * @param r \f$r\f$;
 * @param th \f$\theta\f$;
 * @param ph \f$\phi\f$
 *
 * @return 0 on success
 *
 */

 gint wbfmm_cartesian_to_spherical(gdouble
							*x0, gdouble *x,
							gdouble *r,
							gdouble *th,
							gdouble *ph) {}

/**
 *
 * @ingroup util
 *
 * @brief Perform recursion on normalized associated Legendre functions
 *
 * Perform recursion on normalized associated Legendre functions with
 * input \f$P_{n-1}^{m}(\cos\theta)\f$, \f$0\leq m\leq n-1\f$, and
 * \f$P_{n}^{m}(\cos\theta)\f$, \f$0\leq m \leq n\f$, generating
 * equivalent outputs with \f$n\f$ incremented by one. Note that the
 * arrays of associated Legendre functions are switched internally to
 * ensure that the ordering remains correct after the recursion step. 
 *
 * @param Pnm1 pointer to array of normalized associated Legendre functions
 * for \f$n-1\f$;
 * @param Pn pointer to array of normalized associated Legendre functions 
 * for \f$n\f$;
 * @param n order of \a Pn;
 * @param C \f$\cos\theta\f$;
 * @param S \f$\sin\theta\f$;
 *
 * @return 0 on success
 *
 */

 gint wbfmm_legendre_recursion_array(gdouble **Pnm1,
							  gdouble **Pn,
							  gint n,
							  gdouble C,
							  gdouble S) {}

 /**
 *
 * @ingroup util
 *
 * @brief Initialize normalized associated Legendre functions
 *
 * @param C \f$\cos\theta\f$;
 * @param S \f$\sin\theta\f$;
 * @param P0 on output \f$P_{0}^{0}(\cos\theta)\f$;
 * @param P10 on output \f$P_{1}^{0}(\cos\theta)\f$;
 * @param P11 on output \f$P_{1}^{1}(\cos\theta)\f$;
 *
 * @return 0 on success
 *
 */
 gint wbfmm_legendre_init(gdouble C, gdouble S, 
					       gdouble *P0, gdouble *P10,
					       gdouble *P11) {}

/**
 *
 * @ingroup util
 *
 * @brief Perform recursion on spherical Bessel function \f$j_{n}(x)\f$
 *
 * Perform one step of the spherical Bessel function recursion. On
 * entry \a jnm1 and \a jnm contain \f$j_{n-1}(x)\f$ and
 * \f$j_{n}(x)\f$ respectively. On exit they contain equivalent values
 * but for \f$n\f$ incremented by one. When \f$x\f$ falls below a
 * small order-dependent cutoff, where the recursion is unreliable,
 * \f$j_{n}(x)\f$ is computed directly using a power series.
 *
 * @param jnm1 \f$j_{n-1}(x)\f$;
 * @param jn \f$j_{n}(x)\f$;
 * @param x argument of spherical Bessel function;
 * @param n order of spherical Bessel function
 *
 * @return 0 on success
 *
 */
 gint wbfmm_bessel_j_recursion(gdouble *jnm1,
						    gdouble *jn,
						    gdouble x, gint n) {}

/**
 *
 * @ingroup util
 *
 * @brief Initialize the spherical Bessel function recursion
 *
 * @param x argument of \f$j_{n}(x)\f$;
 * @param j0 on exit \f$j_{0}(x)\f$;
 * @param j1 on exit \f$j_{1}(x)\f$
 *
 * @return 0 on success
 *
 */

 gint wbfmm_bessel_j_init(gdouble x,
					       gdouble *j0, gdouble *j1)
 {}

 /**
 *
 * @ingroup util
 *
 * @brief Initialize spherical Hankel function recursion
 *
 * @param x argument of \f$h_{n}(x)\f$;
 * @param h0 on exit \f$h_{0}(x)\f$;
 * @param h1 on exit \f$h_{1}(x)\f$
 *
 * @return 0 on success
 *
 */
 gint wbfmm_bessel_h_init(gdouble x,
					       gdouble *h0,
					       gdouble *h1) {}

/**
 *
 * @ingroup util
 *
 * @brief Perform one step of spherical Hankel recursion
 *
 * Perform one step of the spherical Hankel function recursion. On
 * entry \a hnm1 and \a hnm contain \f$h_{n-1}(x)\f$ and
 * \f$h_{n}(x)\f$ respectively. On exit they contain equivalent values
 * but for \f$n\f$ incremented by one. When \f$x\f$ falls below a
 * small order-dependent cutoff, where the recursion is unreliable,
 * \f$h_{n}(x)\f$ is computed directly using a power series.
 *
 * @param hnm1 \f$h_{n-1}(x)\f$;
 * @param hn \f$h_{n}(x)\f$;
 * @param x argument of spherical Hankel function;
 * @param n order of spherical Hankel function
 *
 * @return 0 on success
 *
 */
 gint wbfmm_bessel_h_recursion(gdouble *hnm1,
						    gdouble *hn,
						    gdouble x, gint n) {}

/**
 *
 * @ingroup util
 *
 * @brief Compute total field from dipole sources by direct evaluation
 *
 * Evaluate the field at some point \f$\mathbf{x}\f$ by direct
 * evaluation of the sum over sources at \f$\mathbf{x}_{n}\f$
 * \f$\sum_{n=1}^{N}\mathbf{f}_{n}.\nabla 
 * h_{0}(\mathbf{x}-\mathbf{x}_{n})/4\pi\f$.
 * 
 *
 * @param k wavenumber;
 * @param xs array of source positions;
 * @param xstride stride in \a xs between source positions;
 * @param src array of complex vector source strengths;
 * @param sstride stride in \a src;
 * @param nsrc number of sources;
 * @param xf point for field evaluation;
 * @param field incremented with computed field
 *
 * @return 0 on success
 *
 */

 gint wbfmm_total_dipole_field(gdouble k,
						    gdouble *xs,
						    gint xstride,
						    gdouble *src,
						    gint sstride,
						    gint nsrc,
						    gdouble *xf,
						    gdouble *field) {}
   
/**
 *
 * @ingroup util
 *
 * @brief Compute total field by direct evaluation
 *
 * Evaluate the field at some point \f$\mathbf{x}\f$ by direct
 * evaluation of the sum over sources at \f$\mathbf{x}_{n}\f$
 * \f$\sum_{n=1}^{N}s_{n}h_{0}(\mathbf{x}-\mathbf{x}_{n})/4\pi\f$.
 *
 * @param k wavenumber;
 * @param xs array of source positions;
 * @param xstride stride in \a xs between source positions;
 * @param src array of complex scalar source strengths;
 * @param sstride stride in \a src;
 * @param nq number of source elements;
 * @param nsrc number of sources;
 * @param xf point for field evaluation;
 * @param field incremented with computed field;
 * @param fstr stride in field array between components.
 *
 * @return 0 on success
 *
 */
gint wbfmm_total_field(gdouble k, gdouble
					    *xs, gint xstride, gdouble
					    *src, gint sstride, gint nq,
					    gint nsrc,
					    gdouble *xf, gdouble
					    *field) {}

/**
 *
 * @ingroup util
 *
 * @brief Transform coordinates to rotated axes
 *
 * @param x point coordinates in original axes;
 * @param ix unit vector in new axes;
 * @param iy unit vector in new axes;
 * @param iz unit vector in new axes;
 * @param y point coordinates in new axes
 *
 * @return 0 on success
 *
 */

 gint wbfmm_coordinate_transform(gdouble *x,
						      gdouble *ix,
						      gdouble *iy,
						      gdouble *iz,
						      gdouble *y) {}

 /**
 *
 * @ingroup util
 *
 * @brief Find system of axes for coordinate shift
 *
 * @param x origin of shift;
 * @param y point to shift to;
 * @param ix on output unit vector of shift axes;
 * @param iy on output unit vector of shift axes;
 * @param iz on output unit vector of shift axes in direction of shift;
 * @param r distance between two input points
 *
 * @return 0 on success
 *
 */

 gint wbfmm_shift_coordinates(gdouble *x,
						   gdouble *y,
						   gdouble *ix,
						   gdouble *iy,
						   gdouble *iz,
						   gdouble *r) {}

 /**
 *
 * @ingroup util
 *
 * @brief Find the coordinates of a box from its Morton index
 *
 * @param idx Morton index of box;
 * @param level level in octree of box;
 * @param x0 origin of top-level box;
 * @param D width of top-level box;
 * @param x coordinates of box \a idx at level \a level;
 * @param wb width of box at level \a level
 *
 * @return 0 on success
 *
 */
 gint wbfmm_box_location_from_index(guint64 idx,
							 guint32 level,
							 gdouble *x0,
							 gdouble D,
							 gdouble *x,
							 gdouble *wb) {}

/**
 *
 * @ingroup util
 *
 * @brief Find centre and width of box in an octree
 *
 * @param t an octree;
 * @param level level inside \a t;
 * @param b Morton index of box at level \a level;
 * @param xb centre of box with index \a b at level \a level;
 * @param wb width of box at level \a level;
 *
 * @return 0 on success
 *
 */

 gint wbfmm_tree_box_centre(wbfmm_tree_t *t, guint32 level,
						 guint64 b, gdouble *xb,
						 gdouble *wb) {}

/**
 *
 * @ingroup util
 *
 * @brief Find limits of a cube containing a set of points
 *
 * @param x array of points coordinates;
 * @param str stride of points in \a x;
 * @param n number of points in \a x;
 * @param xmin origin of cube containing all points in \a x;
 * @param D width of cube containing all points in \a x;
 * @param init_limits if TRUE initialize limits overwriting any data in xmin
 *
 * @return 0 on success
 *
 */
 gint wbfmm_points_origin_width(gdouble *x,
						     gint str, gint n,
						     gdouble *xmin,
						     gdouble *D,
						     gboolean init_limits) {}

/**
 *
 * @ingroup util
 *
 * @brief Compute angles and distance to shift expansion between two points
 *
 * This is a combination of a call to
 * ::wbfmm_shift_coordinates(...) and 
 * ::wbfmm_rotation_angles(...)
 *
 * @param xi origin of shift;
 * @param xj destination of shift;
 * @param th \f$\theta\f$ for shift;
 * @param ph \f$\phi\f$ for shift;
 * @param ch \f$\chi\f$ for shift;
 * @param r  distance between source and destination points
 *
 * @return 0 on success
 *
 */

 gint wbfmm_shift_angles(gdouble *xi, gdouble *xj,
					      gdouble *th, gdouble *ph,
					      gdouble *ch, gdouble *r) {}

 /**
 *
 * @ingroup util
 *
 * @brief Write a tree source list to file
 *
 * Write to file a list of source positions attached to an octree, in
 * order of Morton index by which they are attached to leaf boxes. If
 * source strengths are supplied (\a q not NULL) these are also
 * written to file.
 *
 * @param t an octree with a list of sources attached;
 * @param q source strengths (if NULL, source strengths are not written);
 * @param stride source strength stride in \a q;
 * @param f output file to write to
 *
 * @return 0 on success
 *
 */
 gint wbfmm_tree_write_sources(wbfmm_tree_t *t,
						    gdouble *q, gint stride,
						    FILE *f) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Generation of singular expansion coefficients for point
 * source in Laplace problem
 *
 * @param N order of expansion;
 * @param x0 origin of expansion;
 * @param xs source position;
 * @param q  source strength(s);
 * @param nq number of components in \a q;
 * @param cfft on output, incremented with coefficients of expansion;
 * @param cstr stride in \a cfft (must be at least equal to \a nq);
 * @param work workspace.
 *
 * @return 0 on success
 *
 */
gint wbfmm_laplace_expansion_cfft(gint N,
						       gdouble *x0,
						       gdouble *xs,
						       gdouble *q, gint nq,
						       gdouble *cfft,
						       gint cstr,
							gdouble *work) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Evaluate a singular expansion for Laplace problem
 *
 * @param x0 origin of expansion;
 * @param cfft on output, incremented with coefficients of expansion;
 * @param cstr stride in \a cfft (must be at least equal to \a nq);
 * @param N order of expansion;
 * @param nq number of components in \a q;
 * @param xf field point;
 * @param field computed potential for each of the \a nq components;
 * @param work workspace.
 *
 * @return 0 on success
 *
 */

gint wbfmm_expansion_laplace_evaluate(gdouble *x0,
							   gdouble *cfft,
							   gint cstr, gint N,
							   gint nq,
							   gdouble *xf,
							   gdouble *field,
							   gdouble *work) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Evaluate the gradient of a singular expansion for Laplace problem
 *
 * @param x0 origin of expansion;
 * @param cfft on output, incremented with coefficients of expansion;
 * @param cstr stride in \a cfft (must be at least equal to \a nq);
 * @param N order of expansion;
 * @param nq number of components in \a q;
 * @param xf field point;
 * @param field computed potential for each of the \a nq components;
 * @param fstr stride in \a field
 * @param work workspace.
 *
 * @return 0 on success
 *
 */

gint wbfmm_expansion_laplace_grad_evaluate(gdouble *x0,
								gdouble *cfft,
								gint cstr, gint N,
								gint nq,
								gdouble *xf,
								gdouble *field,
								gint fstr,
								gdouble *work) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Singular to singular translation for Laplace expansion
 *
 * Translate a singular expansion for the Laplace problem along the
 * \f$z\f$ axis to a singular expansion about a new centre.  Before
 * any Laplace translation function is called, the translation
 * coefficients must be initialized with a call to
 * ::wbfmm_laplace_coaxial_translate_init(...)
 *
 * @param Co on output, expansion about new centre;
 * @param cstro stride in \a Co;
 * @param No order of expansion in \a Co;
 * @param Ci input expansion coefficients;
 * @param cstri stride in \a Ci;
 * @param Ni order of expansion in \a Ci;
 * @param nq number of source terms in expansion;
 * @param t distance to translate expansion.
 * 
 * @return 0 on success
 *
 **/

gint wbfmm_laplace_coaxial_translate_SS(gdouble *Co,
							     gint cstro,
							     gint No,
							     gdouble *Ci,
							     gint cstri,
							     gint Ni,
							     gint nq,
							     gdouble t) {}

/** 
 * 
 * @ingroup laplace
 *
 * @brief Upward shift of singular expansion from eight children to 
 * common parent in Laplace problem
 *
 * Shift the expansion of eight child boxes to their parent and sum
 * into the parent expansion. This function assumes data are packed
 * with a stride of eight elements so that all expansion coefficients
 * of a given order are contiguous in memory, ordered by Morton index. 
 *
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param nq number of elements in source;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param H47 rotation coefficients for `upper' children (Morton index 4-7);
 * @param Lh maximum order of rotation coefficients;
 * @param wb child box width;
 * @param work workspace
 *
 * @return 0 on success
 */

gint wbfmm_laplace_child_parent_shift(gdouble *Cp,
							   gint Np,
							   gdouble *Cc,
							   gint Nc,
							   gint nq,
							   gdouble *H03, 
							   gdouble *H47,
							   gint Lh,
							   gdouble wb,
							   gdouble *work) {}

/** 
 * 
 * @ingroup laplace
 *
 * @brief Upward shift of singular expansion from eight children to 
 * common parent in Laplace problem
 *
 * Shift the expansion of eight child boxes to their parent and sum
 * into the parent expansion. This function assumes data are packed
 * with a stride of eight elements so that all expansion coefficients
 * of a given order are contiguous in memory, ordered by Morton index,
 * using the backward translation method of
 * ::wbfmm_child_parent_shift_bw(...)
 *
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param nq number of elements in source;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param Lh maximum order of rotation coefficients;
 * @param wb child box width;
 * @param work workspace
 *
 * @return 0 on success
 */

gint wbfmm_laplace_child_parent_shift_bw(gdouble *Cp,
							      gint Np,
							      gdouble *Cc,
							      gint Nc,
							      gint nq,
							      gdouble *H03, 
							      gint Lh,
							      gdouble wb,
							      gdouble
							      *work) {} ;

/** 
 * 
 * @ingroup laplace
 *
 * @brief Downward shift of regular expansion from parent to eight
 * children in Laplace problem
 *
 * Shift the expansion of a parent box to its eight child boxes. This
 * function assumes data are packed with a stride of eight elements so
 * that all expansion coefficients of a given order are contiguous in
 * memory, ordered by Morton index. Note that rotation coefficients \a
 * H03 and \a H47 are the same as for the upward pass but switched
 * (because the rotations are performed in the opposite direction).
 *
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param nq number of elements in source;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param H47 rotation coefficients for `upper' children (Morton index 4-7);
 * @param Lh maximum order of rotation coefficients;
 * @param wb parent box width;
 * @param work workspace
 *
 * @return 0 on success
 */

gint wbfmm_laplace_parent_child_shift(gdouble *Cc,
							   gint Nc,
							   gdouble *Cp,
							   gint Np,
							   gint nq,
							   gdouble *H03, 
							   gdouble *H47,
							   gint Lh,
							   gdouble wb,
							   gdouble *work) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Generate coefficients for evaluation of field from
 * (singular) expansion coefficients in the Laplace problem. The
 * coefficients from this function can be applied to an expansion
 * using ::wbfmm_laplace_expansion_apply(...)
 * 
 * @param x location of evaluation point relative to centre of expansion;
 * @param N order of expansion;
 * @param grad if TRUE generate coefficients for gradient of field;
 * @param cfft on exit contains evaluation coefficients;
 * @param work workspace.
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_field_coefficients(gdouble *x,
							   gint N,
							   gboolean grad,
							   gdouble *cfft,
							   gdouble *work) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Apply evaluation coefficients to coefficients of an
 * expansion to evaluate the Laplace potential. Evaluation
 * coefficients can be evaluated using
 * wbfmm_laplace_field_coefficients) or
 * wbfmm_laplace_local_coefficients) for the field
 * (singular) or local (regular) expansions respectively.
 * 
 * @param C coefficients of expansion;
 * @param cstr stride in \a C;
 * @param nq number of source terms in \a C;
 * @param ec evaluation coefficients;
 * @param N order of expansion;
 * @param f on exit contains evaluated field.
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_expansion_apply(gdouble *C,
							gint cstr,
							gint nq,
							gdouble *ec,
							gint N,
							gdouble *f) {}

/** 
 * 
 * @ingroup laplace
 *
 * @brief Generate coefficients for evaluation of local field from
 * (regular) expansion coefficients in the Laplace problem. The
 * coefficients from this function can be applied to an expansion
 * using ::wbfmm_laplace_expansion_apply(...)
 * 
 * @param x location of evaluation point relative to centre of expansion;
 * @param N order of expansion;
 * @param grad if TRUE generate coefficients for gradient of field;
 * @param cfft on exit contains evaluation coefficients;
 * @param work workspace.
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_local_coefficients(gdouble *x,
							   gint N,
							   gboolean grad,
							   gdouble *cfft,
							   gdouble *work) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Evaluate local Laplace field from regular expansion in box
 *
 * @param t octree for domain;
 * @param level level of \a t;
 * @param b box index at level \a level of \a t;
 * @param x location of evaluation point;
 * @param f on output, field value (not zeroed before evaluation);
 * @param src source strengths;
 * @param sstr stride of data in \a src;
 * @param normals normals for dipole sources;
 * @param nstr stride in \a normals;
 * @param d dipole source strengths, or dipole vectors;
 * @param dstr stride in \a d;
 * @param eval_neighbours if TRUE compute contributions from sources 
 * in box \a b and neighbours; 
 * @param work workspace.
 *
 * @return 0 on success
 */

gint wbfmm_tree_laplace_box_local_field(wbfmm_tree_t *t,
							     guint level,
							     guint b,
							     gdouble *x,
							     gdouble *f,
							     gdouble *src,
							     gint sstr,
							     gdouble
							     *normals,
							     gint nstr,
							     gdouble *d,
							     gint dstr,
							     gboolean
							     eval_neighbours,
							     gdouble *work) {}

/** 
 * 
 * @ingroup laplace
 *
 * @brief Evaluate the Laplace field generated by all boxes on a given
 * level of an octree
 * 
 * @param t octree;
 * @param level level at which to use expansions;
 * @param xf field evaluation point;
 * @param field on output contains the sum of singular expansions from 
 * each box on level \a level evaluated at \a xf;
 * @param work workspace.
 *
 * @return 0 on success
 *
*/

gint wbfmm_box_fields_laplace(wbfmm_tree_t *t,
						   gint level,
						   gdouble *xf,
						   gdouble *field,
						   gdouble *work) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Generate leaf expansions for a tree in the Laplace problem
 *
 * Generate leaf expansions for a tree for the Laplace problem given
 * some combination of monopole and dipole sources. Source positions
 * are those in the point list attached to the tree using
 * ::wbfmm_tree_add_points(...) and indexing in
 * the array must correspond to that in the point list. Input arrays
 * may be NULL: if \a src is not NULL, it is interpreted as a list of
 * monopole strengths; if \a normals is not NULL, \a dipoles may not
 * be NULL and they are interpreted respectively as a vector
 * (`normal') at each source position and a scalar amplitude (this
 * corresponds to surface normal and a normal velocity amplitude in a
 * boundary element method calculation); if \a normals is NULL and \a
 * dipoles is not NULL, \a dipoles is interpreted as a three-element
 * vector specifying the dipole strength. The strides \a sstr, \a
 * nstr, and \a dstr are the number of scalar elements between
 * successive entries in the arrays, with the elements of each entry
 * densely packed. For example, a list of normals might read:
 *
 * \f$[n_{x1}\quad n_{y1}\quad n_{z1}\quad a_{1}\quad b_{1}\quad n_{x2}
 * \ldots]\f$
 *
 * where \f$(n_{x1},n_{y1},n_{z1})\f$ is the first normal vector and
 * \f$a_{1}\f$ and \f$b_{1}\f$ are arbitrary entries in the array. In
 * this case, the stride \a nstr would be 5, the number of elements
 * between successive values of \f$n_{xi}\f$. 
 *
 * @param t octree for problem;
 * @param src monopole source strengths;
 * @param sstr stride of data in \a src;
 * @param normals dipole normals;
 * @param nstr stride of data in \a normals;
 * @param dipoles dipole source strengths (if \a normals is not NULL), or 
 * moment vectors (if \a normals is NULL);
 * @param dstr stride of data in \a dipoles;
 * @param zero_expansions if TRUE, set expansion coefficients to zero
 * before adding source terms;
 * @param work workspace.
 *
 * @return 0 on success
 */

gint wbfmm_tree_laplace_leaf_expansions(wbfmm_tree_t *t,
							     gdouble *src,
							     gint sstr,
							     gdouble
							     *normals,
							     gint nstr,
							     gdouble
							     *dipoles,
							     gint dstr,
							     gboolean
							     zero_expansions,
							     gdouble *work) {}

gint wbfmm_tree_laplace_coefficient_init(wbfmm_tree_t *t,
							      guint l, 
							      guint nr,
							      guint ns) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Initialize lookup tables of Laplace translation coefficients 
 *
 * Initialize lookup tables of Laplace translation coefficients for use
 * in coaxial translation of Laplace expansions. This function must be
 * called before any coaxial translation is performed in a Laplace
 * problem.
 * 
 * @param N maximum order of expansion to be translated.
 *
 * @return 0 on success
 *
 */

 gint wbfmm_laplace_coaxial_translate_init(gint N) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Singular to regular translation for Laplace expansion
 *
 * Translate a singular expansion for the Laplace problem along
 * the \f$z\f$ axis to a regular expansion about a new centre. Before
 * any Laplace translation function is called, the translation
 * coefficients must be initialized with a call to
 * ::wbfmm_laplace_coaxial_translate_init(...)
 *
 * @param Co on output, expansion about new centre;
 * @param cstro stride in \a Co;
 * @param No order of expansion in \a Co;
 * @param Ci input expansion coefficients;
 * @param cstri stride in \a Ci;
 * @param Ni order of expansion in \a Ci;
 * @param nq number of source terms in expansion;
 * @param t distance to translate expansion.
 * 
 * @return 0 on success
 *
 **/

gint wbfmm_laplace_coaxial_translate_SR(gdouble *Co,
							     gint cstro,
							     gint No,
							     gdouble *Ci,
							     gint cstri,
							     gint Ni,
							     gint nq,
							     gdouble t) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Regular to regular translation for Laplace expansion
 *
 * Translate a regular expansion for the Laplace problem along
 * the \f$z\f$ axis to a regular expansion about a new centre. Before
 * any Laplace translation function is called, the translation
 * coefficients must be initialized with a call to
 * ::wbfmm_laplace_coaxial_translate_init(...)
 *
 * @param Co on output, expansion about new centre;
 * @param cstro stride in \a Co;
 * @param No order of expansion in \a Co;
 * @param Ci input expansion coefficients;
 * @param cstri stride in \a Ci;
 * @param Ni order of expansion in \a Ci;
 * @param nq number of source terms in expansion;
 * @param t distance to translate expansion.
 * 
 * @return 0 on success
 *
 **/

gint wbfmm_laplace_coaxial_translate_RR(gdouble *Co,
							     gint cstro,
							     gint No,
							     gdouble *Ci,
							     gint cstri,
							     gint Ni,
							     gint nq,
							     gdouble t) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Direct evaluation of the Laplace field from a list of sources
 * 
 * @param xs source positions
 * @param xstride source array stride
 * @param src source strengths
 * @param sstride source strength array stride
 * @param nq number of source components
 * @param normals normals at source positions
 * @param nstr normal stride
 * @param dipoles dipole components
 * @param dstr dipole stride
 * @param nsrc number of sources
 * @param xf field point
 * @param field on output incremented with computed field
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_field_grad(gdouble *xs, gint xstride,
						   gdouble *src, gint sstride,
						   gint nq,
						   gdouble *normals, gint nstr,
						   gdouble *dipoles, gint dstr,
						   gint nsrc,
						   gdouble *xf, gdouble *field) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Direct evaluation of the gradient of a Laplace field from a
 * list of sources
 * 
 * @param xs source positions
 * @param xstride source array stride
 * @param src source strengths
 * @param sstride source strength array stride
 * @param nq number of source components
 * @param normals normals at source positions
 * @param nstr normal stride
 * @param dipoles dipole components
 * @param dstr dipole stride
 * @param nsrc number of sources
 * @param xf field point
 * @param field on output incremented with computed field
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_field(gdouble *xs, gint xstride,
					      gdouble *src, gint sstride,
					      gint nq,
					      gdouble *normals, gint nstr,
					      gdouble *dipoles, gint dstr,
					      gint nsrc,
					      gdouble *xf, gdouble *field) {}


gint wbfmm_laplace_coaxial_translate_RR(gdouble *Co,
							     gint cstro,
							     gint No,
							     gdouble *Ci,
							     gint cstri,
							     gint Ni,
							     gint nq,
							     gdouble t) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Direct evaluation of the Laplace from a list of sources
 * 
 * @param xs source positions
 * @param xstride source array stride
 * @param src source strengths
 * @param sstride source strength array stride
 * @param nq number of source components
 * @param normals normals at source positions
 * @param nstr normal stride
 * @param dipoles dipole components
 * @param dstr dipole stride
 * @param nsrc number of sources
 * @param xf field point
 * @param field on output incremented with computed field
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_field(gdouble *xs, gint xstride,
					      gdouble *src, gint sstride,
					      gint nq,
					      gdouble *normals, gint nstr,
					      gdouble *dipoles, gint dstr,
					      gint nsrc,
					      gdouble *xf, gdouble *field) {}


/** 
 *
 * @ingroup laplace
 *
 * @brief 
 * 
 * @param 
 * @param 
 * @param 
 * @param 
 * @param 
 * @param 
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_expansion_local_evaluate(gdouble *x0,
								 gdouble
								 *cfft,
								 gint cstr, 
								 gint N,
								 gint nq,
								 gdouble *xf,
								 gdouble
								 *field,
								 gdouble
								 *work) {}

/**
 * @ingroup rotations
 * @brief Apply rotation \f$(\theta,\phi\,\chi)\f$ to multipole
 * coefficients for the Laplace problem
 * 
 * Given the rotation coefficients \a H for angle \f$\theta\f$ from 
 * ::wbfmm_coefficients_H_rotation(...), rotate input
 * coefficients to new system of axes, using \a H and angles
 * \f$\phi\f$ and \f$\chi\f$. Input and output are strided arrays of
 * dense complex data with spacing between adjacent complex values
 * given as \a cstri and \a cstro elements respectively. Thus, \a Co for
 * example is packed as:
 *
 * \f$[\Re(C_{00})\quad \Im(C_{00}) \ldots (2\times\mbox{cstro})
 * \ldots \Re(C_{0,-1})\quad \Im(C_{0,-1})]\f$
 *
 * This stride system allows for packing data more conveniently for
 * upward and downward passes in the FMM proper. 
 *
 * @param Co on output contains rotated coefficients;
 * @param cstro stride in \a Co, in number of complex elements;
 * @param Ci input coefficients, to be rotated;
 * @param cstri stride in \a Ci, in number of complex elements;
 * @param N maximum order of coefficients;
 * @param nq number of source terms;
 * @param H rotation coefficients for angle \f$\theta\f$, from
 * ::wbfmm_coefficients_H_rotation(...);
 * @param ph angle \f$\phi\f$ for rotation;
 * @param ch angle \f$\chi\f$ for rotation.
 *
 * @return 0 on success
 */

gint wbfmm_laplace_rotate_H(gdouble *Co, gint cstro,
						 gdouble *Ci, gint cstri,
						 gint N, gint nq,
						 gdouble *H,
						 gdouble ph, gdouble ch) {}

 /**
 *
 * @ingroup pass
 *
 * @brief Perform downward pass at one level of an octree for the
 * Laplace problem
 *
 * Perform one stage of a downward pass for tree levels greater than
 * or equal to two. The actions performed are the evaluation of the
 * list 4 contribution to the regular expansion and, for non-leaf
 * boxes, a downward shift of the regular expansions to the child
 * boxes at the next level.
 *
 * @param t an initialized octree which has had the upward pass performed;
 * @param op shift operators allocated for \a t;
 * @param level level at which to perform downward pass;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_laplace_downward_pass(wbfmm_tree_t *t,
						      wbfmm_shift_operators_t
						      *op,
						      guint level,
						      gdouble *work) {}
/**
 *
 * @ingroup pass
 *
 * @brief Perform upward pass at one level of an octree for the
 * Laplace problem
 *
 * Perform one stage of the upward pass in an octree. The action
 * performed is the upward shift of the singular expansions from boxes
 * at level \a level to their parents. 
 *
 * @param t an initialized octree;
 * @param op shift operators allocated for \a t;
 * @param level level at which to perform upward pass;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_laplace_upward_pass(wbfmm_tree_t *t,
						    wbfmm_shift_operators_t *op,
						    guint level,
						    gdouble *work) {}
/** 
 * @ingroup boxes
 *
 * @brief Add points to an octree
 *
 * Add a set of source points to an octree. The points are assumed to
 * be in an array of real values with components in a packed triple,
 * indexed using a stride of pstr bytes (this allows for quite general
 * handling of different source formats). 
 * 
 * @param t an existing ::wbfmm_tree_t;
 * @param pts an array containing point coordinates;
 * @param npts the number of points in \a pts;
 * @param pstr stride between points in bytes.
 * 
 * @return 0 on success.
 */

gint wbfmm_tree_add_points_f(wbfmm_tree_t *t, 
						gpointer pts, guint npts,
						gsize pstr) {}

/** 
 * @ingroup rotations
 * @brief Compute the rotation angles \f$(\theta,\phi,\chi)\f$ between axes
 *
 * Compute the angles for rotation between two systems of axes 
 * \f$(\mathbf{i}_{x}, \mathbf{i}_{y}, \mathbf{i}_{z})\f$ and
 * \f$(\mathbf{j}_{x}, \mathbf{j}_{y}, \mathbf{j}_{z})\f$, as
 *  defined in Section 5 of Gumerov and Duraiswami. All vectors
 * should be unit length and form a right-handed coordinate system 
 * (no check is performed).
 * 
 * @param ix initial coordinate system \f$x\f$ axis;
 * @param iy initial coordinate system \f$y\f$ axis;
 * @param iz initial coordinate system \f$z\f$ axis;
 * @param jx rotated coordinate system \f$x\f$ axis;
 * @param jy rotated coordinate system \f$y\f$ axis;
 * @param jz rotated coordinate system \f$z\f$ axis;
 * @param th on exit, \f$\theta\f$ for rotation;
 * @param ph on exit, \f$\phi\f$ for rotation;
 * @param ch on exit, \f$\chi\f$ for rotation.
 * 
 * @return 0 on success
 */

gint wbfmm_rotation_angles_f(gfloat *ix, gfloat *iy,
						gfloat *iz, gfloat *jx,
						gfloat *jy, gfloat *jz,
						gfloat *th, gfloat *ph,
						gfloat *ch) {}

/**
 * @ingroup rotations
 * @brief Compute rotation coefficients for angle \f$\theta\f$
 *
 * Generate the coefficients required to rotate one multipole
 * expansion to a new orientation, using Gumerov and Duraiswami,
 * Section 5, equation (5.48) and recursion (5.55). Coefficients \a H
 * are real and densely packed on output.
 *
 * @param H on output rotation coefficients;
 * @param N maximum order of coefficients to compute;
 * @param th rotation angle \f$\theta\f$, from 
 * ::wbfmm_rotation_angles_f(...);
 * @param work workspace
 *
 * @return 0 on success
 */
 gint wbfmm_coefficients_H_rotation_f(gfloat *H,
							 gint N, gfloat th,
							 gfloat *work) {}
 
/**
 * @ingroup rotations
 * @brief Apply rotation \f$(\theta,\phi\,\chi)\f$ to multipole
 * coefficients
 * 
 * Given the rotation coefficients \a H for angle \f$\theta\f$ from 
 * ::wbfmm_coefficients_H_rotation_f(...), rotate input
 * coefficients to new system of axes, using \a H and angles
 * \f$\phi\f$ and \f$\chi\f$. Input and output are strided arrays of
 * dense complex data with spacing between adjacent complex values
 * given as \a cstri and \a cstro elements respectively. Thus, \a Co for
 * example is packed as:
 *
 * \f$[\Re(C_{00})\quad \Im(C_{00}) \ldots (2\times\mbox{cstro})
 * \ldots \Re(C_{0,-1})\quad \Im(C_{0,-1})]\f$
 *
 * This stride system allows for packing data more conveniently for
 * upward and downward passes in the FMM proper. 
 *
 * The function is available as a reference version
 * wbfmm_rotate_H_ref_f(...) and an optimized version
 * wbfmm_rotate_H_avx_f(...) which uses AVX
 * optimizations if available. The compile time switch -DWBFMM_USE_AVX
 * selects the AVX version. 
 *
 * @param Co on output contains rotated coefficients;
 * @param cstro stride in \a Co, in number of complex elements;
 * @param Ci input coefficients, to be rotated;
 * @param cstri stride in \a Ci, in number of complex elements;
 * @param N maximum order of coefficients;
 * @param nq number of source components;
 * @param H rotation coefficients for angle \f$\theta\f$, from
 * ::wbfmm_coefficients_H_rotation_f(...);
 * @param ph angle \f$\phi\f$ for rotation;
 * @param ch angle \f$\chi\f$ for rotation.
 *
 * @return 0 on success
 */

gint wbfmm_rotate_H_f(gfloat *Co, gint cstro,
					 gfloat *Ci, gint cstri,
					 gint N, gint nq,
					 gfloat *H, gfloat ph,
					 gfloat ch) {}

/**     
 * @fn gint wbfmm_coefficients_RR_coaxial_f(gfloat
 * *cfftRR, gint L, gfloat kr, gfloat *work)
 *
 * @ingroup translations
 *
 * @brief Generate coefficients for coaxial regular-to-regular translation
 *
 * Generate translation coefficients for a regular-to-regular coaxial
 * shift along the \f$z\f$ axis of the local coordinate system, by
 * distance \f$r\f$ for wavenumber \f$k\f$, using the methods of
 * Section 4.8 of Gumerov and Duraiswami. The regular-to-regular
 * translation coefficients are identical to the singular-to-singular
 * coefficients and are real.
 *
 * @param cfftRR on output contains (real) translation coefficients;
 * @param L maximum order of multipole expansion to be translated;
 * @param kr coaxial translation parameter (wavenumber times distance);
 * @param work workspace
 * 
 * @return 0 on success
 */


/**
 *
 * @ingroup translations
 *
 * @brief Generate coefficients for coaxial singular-to-regular translation
 *
 * Generate translation coefficients for a singular-to-regular coaxial
 * shift along the \f$z\f$ axis of the local coordinate system, by
 * distance \f$r\f$ for wavenumber \f$k\f$, using the methods of
 * Section 4.8 of Gumerov and Duraiswami. The output coefficients are
 * complex.
 *
 * @param cfftSR on output contains (complex) translation coefficients;
 * @param L maximum order of multipole expansion to be translated;
 * @param kr coaxial translation parameter (wavenumber times distance);
 * @param work workspace
 *
 * @return 0 on success
 */

gint wbfmm_coefficients_SR_coaxial_f(gfloat *cfftSR, 
							gint L, gfloat kr,
							gfloat *work) {}


/**
 *
 * @ingroup translations
 *
 * @brief Perform coaxial translation of multipole expansion
 *
 * Compute the coaxial translation of a multipole expansion along its
 * \f$z\f$ axis, using coefficients from
 * ::wbfmm_coefficients_SR_coaxial_f(...) (complex) or
 * ::wbfmm_coefficients_RR_coaxial_f(...) (real). Input
 * and output coefficients are strided data as described for
 * ::wbfmm_rotate_H_f(...).
 *
 * @param Co on output contains translated multipole expansion;
 * @param cstro stride for output data in number of complex elements;
 * @param No order of output expansion;
 * @param Ci input multipole expansion;
 * @param cstri stride for input data in number of complex elements;
 * @param Ni order of input expansion;
 * @param cfft translation coefficients;
 * @param L maximum order of translation coefficients;
 * @param complex if TRUE treat \a cfft as complex
 * (e.g. for singular-to-regular translation); if FALSE treat as real
 * (e.g. regular-to-regular or singular-to-singular).
 *
 * @return 0 on success
 */
 gint wbfmm_coaxial_translate_f(gfloat *Co,
						   gint cstro, gint No,
						   gfloat *Ci,
						   gint cstri, gint Ni,
						   gfloat *cfft,
						   gint L, gboolean complex) {}
 
/**
 *
 * @ingroup boxes
 *
 * @brief Allocate a new octree
 *
 * @param x location of origin of tree;
 * @param D width of domain;
 * @param maxpoints maximum number of source points in tree.
 *
 * @return pointer to newly allocated tree.
 */
 wbfmm_tree_t *wbfmm_tree_new_f(gfloat *x,
						   gfloat D,
						   guint maxpoints) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Generate leaf expansions for a tree
 *
 * Generate leaf expansions for a tree given some combination of
 * monopole and dipole sources. Source positions are those in the
 * point list attached to the tree using
 * ::wbfmm_tree_add_points_f(...) and indexing in the
 * array must correspond to that in the point list. Input arrays may
 * be NULL: if \a src is not NULL, it is interpreted as a list of
 * complex monopole strengths; if \a normals is not NULL, \a dipoles
 * may not be NULL and they are interpreted respectively as a vector
 * (`normal') at each source position and a scalar complex amplitude
 * (this corresponds to surface normal and a normal velocity amplitude
 * in a boundary element method calculation); if \a normals is NULL
 * and \a dipoles is not NULL, \a dipoles is interpreted as a
 * three-element complex vector specifying the dipole strength. The
 * strides \a sstr, \a nstr, and \a dstr are the number of scalar
 * elements between successive entries in the arrays, with the
 * elements of each entry densely packed. For example, a list of
 * normals might read:
 *
 * \f$[n_{x1}\quad n_{y1}\quad n_{z1}\quad a_{1}\quad b_{1}\quad n_{x2}
 * \ldots]\f$
 *
 * where \f$(n_{x1},n_{y1},n_{z1})\f$ is the first normal vector and
 * \f$a_{1}\f$ and \f$b_{1}\f$ are arbitrary entries in the array. In
 * this case, the stride \a nstr would be 5, the number of elements
 * between successive values of \f$n_{xi}\f$. 
 *
 * @param t octree for problem;
 * @param k wavenumber;
 * @param src monopole source strengths;
 * @param sstr stride of data in \a src;
 * @param normals dipole normals;
 * @param nstr stride of data in \a normals;
 * @param dipoles dipole source strengths (if \a normals is not NULL), or 
 * moment vectors (if \a normals is NULL);
 * @param dstr stride of data in \a dipoles;
 * @param zero_expansions if TRUE, set expansion coefficients to zero
 * before adding source terms;
 * @param work workspace.
 *
 * @return 0 on success
 */

 gint wbfmm_tree_leaf_expansions_f(wbfmm_tree_t *t,
						      gfloat k,
						      gfloat *src,
						      gint sstr, 
						      gfloat *normals,
						      gint nstr,
						      gfloat *dipoles,
						      gint dstr,
						      gboolean zero_expansions,
						      gfloat *work) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Evaluate singular expansion about a box centre
 *
 * @param t octree for problem;
 * @param level level in \a t;
 * @param b index of box at level \a level of \a t; 
 * @param k wavenumber;
 * @param x field evaluation point;
 * @param f on output field at \a x (not zeroed before evaluation);
 * @param fstr stride in \a field in number of array entries;
 * @param work workspace
 *
 * @return 0 on success
 */

 gint wbfmm_tree_box_field_f(wbfmm_tree_t *t, guint
						level, guint b, gfloat k,
						gfloat *x, gfloat *f,
						gint fstr,
						gfloat *work) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Evaluate local field from regular expansion in box
 *
 * @param t octree for domain;
 * @param level level of \a t;
 * @param b box index at level \a level of \a t;
 * @param k wavenumber;
 * @param x location of evaluation point;
 * @param f on output, field value (not zeroed before evaluation);
 * @param fstr stride of data in \a f;
 * @param src source strengths;
 * @param sstr stride of data in \a src;
 * @param eval_neighbours if TRUE compute contributions from sources 
 * in box \a b and neighbours; 
 * @param field XOR combination of ::wbfmm_field_t to select output 
 * field type (scalar, gradient, curl, etc.);
 * @param work workspace.
 *
 * @return 0 on success
 */

 gint wbfmm_tree_box_local_field_f(wbfmm_tree_t *t,
						      guint level,
						      guint b, gfloat k,
						      gfloat *x,
						      gfloat *f,
						      gint fstr,
						      gfloat *src,
						      gint sstr,
						      gboolean eval_neighbours,
						      guint field,
						      gfloat *work) {}


/**
 *
 * @ingroup boxes
 *
 * @brief Find Morton index for point in a cubic domain
 *
 * @param x point in space (three components, densely packed);
 * @param c location of bottom left corner of domain;
 * @param D width of domain.
 *
 * @return 0 on success
 */

 guint64 wbfmm_point_index_3d_f(gfloat *x,
						   gfloat *c,
						   gfloat D) {}

/**
 *
 * @ingroup boxes 
 *
 * @brief Initialize expansion coefficient data in an octree
 *
 * @param t octree for problem;
 * @param l level to initialize data for;
 * @param nr order of regular expansions at level \a l;
 * @param ns order of singular expansions at level \a l.
 *
 * @return 0 on success
 */

gint wbfmm_tree_coefficient_init_f(wbfmm_tree_t
						      *t, guint l, guint nr,
						      guint ns) {}

/** 
 *
 * @ingroup boxes
 *
 * @brief
 *
 * Refine an existing octree by adding a level and redistributing
 * points attached to the tree to the boxes at the new level.
 * 
 * @param t an existing ::wbfmm_tree_t.
 * 
 * @return 0 on success.
 */

gint wbfmm_tree_refine_f(wbfmm_tree_t *t) {}

/**
 *
 * @ingroup shift
 *
 * @brief Upward shift of singular expansion from eight children to 
 * common parent
 *
 * Shift the expansion of eight child boxes to their parent and sum
 * into the parent expansion. This function assumes data are packed
 * with a stride of eight elements so that all expansion coefficients
 * of a given order are contiguous in memory, ordered by Morton index. 
 *
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param H47 rotation coefficients for `upper' children (Morton index 4-7);
 * @param Lh maximum order of rotation coefficients;
 * @param trans coaxial translation operator for distance between child and 
 * parent box centres;
 * @param Ls order of \a trans;
 * @param nq number of source components;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_child_parent_shift_f(gfloat *Cp, gint Np,
						   gfloat *Cc, gint Nc,
						   gfloat *H03, 
						   gfloat *H47, gint Lh,
						   gfloat *trans, gint Ls,
						   gint nq,
						   gfloat *work) {}

/**
 *
 * @ingroup shift
 *
 * @brief Upward shift of singular expansion from eight children to 
 * common parent, using backward translations
 *
 * Shift the expansion of eight child boxes to their parent and sum
 * into the parent expansion. This function assumes data are packed
 * with a stride of eight elements so that all expansion coefficients
 * of a given order are contiguous in memory, ordered by Morton
 * index. The method is the same as for
 * ::wbfmm_child_parent_shift_f(...), except that
 * the child boxes with Morton indices 4-7 are rotated in the same
 * sense as the diagonally opposite child boxes 0-3 and a reverse
 * (negative distance) coaxial translation is used to combine them
 * with the lower child box data with the same rotation. The reverse
 * rotation is then applied to the summed data meaning that only four
 * reverse rotations rather than eight are required to transfer the
 * data to the parent box orientation.
 *
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param Lh maximum order of rotation coefficients;
 * @param transf forward (\f$+kr\f$) coaxial translation operator for 
 * distance between child and parent box centres;
 * @param transb backward (\f$-kr\f$) coaxial translation operator for 
 * distance between child and parent box centres;
 * @param Ls order of \a trans;
 * @param work workspace
 *
 * @return 0 on success
 *
 */


gint wbfmm_child_parent_shift_bw_f(gfloat *Cp, gint Np,
						      gfloat *Cc, gint Nc,
						      gfloat *H03, gint Lh,
						      gfloat *transf,
						      gfloat *transb,
						      gint Ls,
						      gfloat *work) {}

/**
 *
 * @ingroup shift
 *
 * @brief Downward shift of parent expansion to child box centres
 *
 * Shift the (regular) expansion data from a parent box to each of its
 * child boxes, assuming the same packing as in
 * ::wbfmm_child_parent_shift_f(...). Note that the
 * rotation matrices for this function are switched relative to the
 * rotations of the same name in
 * ::wbfmm_child_parent_shift_f(...), because the `upper'
 * children rotate `down' to be shifted to the parent centre but the
 * rotation is `up' to shift from the parent to those children, and
 * similarly for the `lower' children.
 *
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param H47 rotation coefficients for `upper' children (Morton index 4-7);
 * @param Lh maximum order of rotation coefficients;
 * @param trans coaxial translation operator for distance between child and 
 * parent box centres;
 * @param Ls order of \a trans;
 * @param nq number of source components;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

  gint wbfmm_parent_child_shift_f(gfloat *Cc, gint Nc,
						   gfloat *Cp, gint Np,
						   gfloat *H03, 
						   gfloat *H47, gint Lh,
						   gfloat *trans, gint Ls,
						   gint nq,
						   gfloat *work) {}

/**
 * @ingroup shift
 *
 * @brief Extract the rotation angles for boxes on interaction list 4
 *
 * Find the rotation angles \f$(\theta,\phi\,\chi)\f$ between a box at
 * integer coordinates \f$(i,j,k)\f$, using a look-up table which
 * should be initialized with
 * ::wbfmm_shift_angle_table_init_f(...)
 *
 * @param i integer \f$x\f$ coordinate of box on interaction list;
 * @param j integer \f$y\f$ coordinate of box on interaction list;
 * @param k integer \f$z\f$ coordinate of box on interaction list;
 * @param th \f$\theta\f$ for rotation between boxes;
 * @param ph \f$\phi\f$ for rotation between boxes;
 * @param ch \f$\chi\f$ for rotation between boxes;
 * @param rs scaling factor for distance between box centres, distance
 * is \a rs multiplied by box width.
 *
 * @return 0 on success
 *
 */

 gint wbfmm_shift_angles_list4_f(gint i, gint j, gint k,
					     gfloat *th, gfloat *ph,
					     gfloat *ch, gfloat *rs) {} 

/**
 *
 * @ingroup shift
 *
 * @brief Initialize table of angles for shift operations
 *
 * This function must be called before any interaction calculations
 * are performed, in particular before any call to
 * ::wbfmm_shift_operators_new_f(...), in order to
 * initialize the look-up table of orientations between boxes in
 * interaction lists.
 *
 *
 * @return 0 on success
 *
 */

gint wbfmm_shift_angle_table_init_f(void) {}
 
/**
 *
 * @ingroup shift 
 *
 * @brief Allocate shift operators and initialize rotations
 *
 * Allocate a new ::wbfmm_shift_operators_t of given maximum order and
 * initialize the rotation coefficients needed for same-level
 * interaction calculations and upward and downward passes.
 *
 * @param L maximum order of expansions;
 * @param bw if TRUE generate operators for backward translation algorithm;
 * @param work workspace.
 *
 * @return 0 on success
 *
 */

wbfmm_shift_operators_t
*wbfmm_shift_operators_new_f(guint L,
						gboolean bw,
						gfloat *work) {}

/**
 *
 * @ingroup shift
 *
 * @brief Initialize singular-to-regular translation operators
 *
 * @param w a ::wbfmm_shift_operators_t allocated with 
 * wbfmm_shift_operators_new_f(...);
 * @param D width of the problem domain;
 * @param level level for which to generate translations;
 * @param L order of translations;
 * @param k wavenumber;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_shift_operators_coaxial_SR_init)
     (wbfmm_shift_operators_t *w, gfloat D, guint level, guint L,
      gfloat k, gfloat *work) {}

/**
 *
 * @ingroup shift
 *
 * @brief Initialize singular-to-singular (regular-to-regular)
 * translation operators
 *
 * @param w a ::wbfmm_shift_operators_t allocated with 
 * wbfmm_shift_operators_new_f(...);
 * @param D width of the problem domain;
 * @param level level for which to generate translations;
 * @param L order of translations;
 * @param k wavenumber;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

 gint wbfmm_shift_operators_coaxial_SS_init)
     (wbfmm_shift_operators_t *w, gfloat D, guint level, 
      guint L, gfloat k, gfloat *work) {}

 /**
 *
 * @ingroup expansions
 *
 * @brief Generation of singular expansion coefficients for point source
 *
 * @param k wavenumber;
 * @param N order of expansion;
 * @param x0 centre of expansion;
 * @param xs source position;
 * @param q complex source strength;
 * @param nq number of source elements;
 * @param cfft incremented with expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

 gint wbfmm_expansion_h_cfft_f(gfloat k, gint N, 
                                                  gfloat *x0,
						  gfloat *xs,
						  gfloat *q, gint nq,
						  gfloat *cfft, gint cstr,
						  gfloat *work) {}

 /**
 *
 * @ingroup expansions
 *
 * @brief Generation of singular expansion coefficients for point dipole source
 *
 * @param k wavenumber;
 * @param N order of expansion;
 * @param x0 centre of expansion;
 * @param xs source position;
 * @param fx component of complex source strength;
 * @param fy component of complex source strength;
 * @param fz component of complex source strength;
 * @param nq number of source elements;
 * @param cfft incremented with expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

 gint wbfmm_expansion_dipole_h_cfft_f(gfloat k, gint N, 
							 gfloat *x0,
							 gfloat *xs,
							 gfloat *fx,
							 gfloat *fy,
							 gfloat *fz,
							 gint nq,
							 gfloat *cfft,
							 gint cstr,
							 gfloat *work) {}


 /**
 *
 * @ingroup expansions
 *
 * @brief Generation of singular expansion coefficients for point
 * dipole source defined as normal and strength
 *
 * @param k wavenumber;
 * @param N order of expansion;
 * @param x0 centre of expansion;
 * @param xs source position;
 * @param normal normal vector for source orientation;
 * @param q complex source strength;
 * @param nq number of source elements;
 * @param cfft incremented with expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param nq number of source elements;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_expansion_normal_h_cfft_f(gfloat k, gint N, 
							gfloat *x0,
							gfloat *xs,
							gfloat *normal,
							gfloat *q,
							gint nq,
							gfloat *cfft,
							gint cstr,
							gfloat *work) ;

/**
 *
 * @ingroup expansions
 *
 * @brief Evaluate a singular expansion
 *
 * @param k wavenumber;
 * @param x0 centre of expansion;
 * @param cfft expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param nq number of source elements;
 * @param N order of expansion;
 * @param xf field point;
 * @param field incremented with computed field;
 * @param fstr stride in \a field, in number of array entries;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_expansion_h_evaluate_f(gfloat k, 
						     gfloat *x0,
						     gfloat *cfft,
						     gint cstr,
						     gint N, 
						     gint nq,
						     gfloat *xf, 
						     gfloat *field,
						     gint fstr,
						     gfloat *work) {}

/**
 *
 * @ingroup expansions
 *
 * @brief Evaluate the gradient of a singular expansion
 *
 * @param k wavenumber;
 * @param x0 centre of expansion;
 * @param cfft expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param N order of expansion;
 * @param nq number of source elements;
 * @param xf field point;
 * @param field incremented with computed gradient;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_expansion_h_grad_evaluate_f(gfloat k, 
							  gfloat *x0,
							  gfloat *cfft,
							  gint cstr,
							  gint N, 
							  gint nq,
							  gfloat *xf, 
							  gfloat *field,
							  gfloat *work) {}


/**
 *
 * @ingroup expansions
 *
 * @brief Evaluate the gradient of a regular expansion
 *
 * @param k wavenumber;
 * @param x0 centre of expansion;
 * @param cfft expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param N order of expansion;
 * @param nq number of source elements;
 * @param xf field point;
 * @param field incremented with computed gradient;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_expansion_j_grad_evaluate_f(gfloat k,
							  gfloat *x0,
							  gfloat *cfft,
							  gint cstr,
							  gint N, 
							  gint nq,
							  gfloat *xf, 
							  gfloat *field,
							  gint fstr,
							  gfloat *work) ;

/**
 *
 * @ingroup expansions
 *
 * @brief Evaluate a regular expansion
 *
 * @param k wavenumber;
 * @param x0 centre of expansion;
 * @param cfft expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param nq number of source elements;
 * @param N order of expansion;
 * @param xf field point;
 * @param field incremented with computed field;
 * @param fstr stride in \a field in number of array entries;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

 gint wbfmm_expansion_j_evaluate_f(gfloat k,
                                                      gfloat *x0,
						      gfloat *cfft,
						      gint cstr, gint nq,
						      gint N, 
						      gfloat *xf, 
						      gfloat *field,
						      gint fstr, 
						      gfloat *work) {}

 /**
 *
 * @ingroup pass
 *
 * @brief Perform downward pass at one level of an octree
 *
 * Perform one stage of a downward pass for tree levels greater than
 * or equal to two. The actions performed are the evaluation of the
 * list 4 contribution to the regular expansion and, for non-leaf
 * boxes, a downward shift of the regular expansions to the child
 * boxes at the next level.
 *
 * @param t an initialized octree which has had the upward pass performed;
 * @param op shift operators allocated for \a t;
 * @param level level at which to perform downward pass;
 * @param work workspace
 *
 * @return 0 on success
 *
 */
 gint wbfmm_downward_pass_f(wbfmm_tree_t *t,
					       wbfmm_shift_operators_t *op,
					       guint level, gfloat *work) {}

/**
 *
 * @ingroup pass
 *
 * @brief Perform upward pass at one level of an octree
 *
 * Perform one stage of the upward pass in an octree. The action
 * performed is the upward shift of the singular expansions from boxes
 * at level \a level to their parents. 
 *
 * @param t an initialized octree;
 * @param op shift operators allocated for \a t;
 * @param level level at which to perform upward pass;
 * @param work workspace
 *
 * @return 0 on success
 *
 */
 gint wbfmm_upward_pass_f(wbfmm_tree_t *t,
					     wbfmm_shift_operators_t *op,
					     guint level, gfloat *work) {}

/**
 *
 * @ingroup util
 *
 * @brief Convert Cartesian to spherical coordinates \f$(r,\theta,\phi)\f$
 *
 * @param x0 centre of coordinate system;
 * @param x point whose coordinates are to be found;
 * @param r \f$r\f$;
 * @param th \f$\theta\f$;
 * @param ph \f$\phi\f$
 *
 * @return 0 on success
 *
 */

 gint wbfmm_cartesian_to_spherical_f(gfloat
							*x0, gfloat *x,
							gfloat *r,
							gfloat *th,
							gfloat *ph) {}

/**
 *
 * @ingroup util
 *
 * @brief Perform recursion on normalized associated Legendre functions
 *
 * Perform recursion on normalized associated Legendre functions with
 * input \f$P_{n-1}^{m}(\cos\theta)\f$, \f$0\leq m\leq n-1\f$, and
 * \f$P_{n}^{m}(\cos\theta)\f$, \f$0\leq m \leq n\f$, generating
 * equivalent outputs with \f$n\f$ incremented by one. Note that the
 * arrays of associated Legendre functions are switched internally to
 * ensure that the ordering remains correct after the recursion step. 
 *
 * @param Pnm1 pointer to array of normalized associated Legendre functions
 * for \f$n-1\f$;
 * @param Pn pointer to array of normalized associated Legendre functions 
 * for \f$n\f$;
 * @param n order of \a Pn;
 * @param C \f$\cos\theta\f$;
 * @param S \f$\sin\theta\f$;
 *
 * @return 0 on success
 *
 */

 gint wbfmm_legendre_recursion_array_f(gfloat **Pnm1,
							  gfloat **Pn,
							  gint n,
							  gfloat C,
							  gfloat S) {}

 /**
 *
 * @ingroup util
 *
 * @brief Initialize normalized associated Legendre functions
 *
 * @param C \f$\cos\theta\f$;
 * @param S \f$\sin\theta\f$;
 * @param P0 on output \f$P_{0}^{0}(\cos\theta)\f$;
 * @param P10 on output \f$P_{1}^{0}(\cos\theta)\f$;
 * @param P11 on output \f$P_{1}^{1}(\cos\theta)\f$;
 *
 * @return 0 on success
 *
 */
 gint wbfmm_legendre_init_f(gfloat C, gfloat S, 
					       gfloat *P0, gfloat *P10,
					       gfloat *P11) {}

/**
 *
 * @ingroup util
 *
 * @brief Perform recursion on spherical Bessel function \f$j_{n}(x)\f$
 *
 * Perform one step of the spherical Bessel function recursion. On
 * entry \a jnm1 and \a jnm contain \f$j_{n-1}(x)\f$ and
 * \f$j_{n}(x)\f$ respectively. On exit they contain equivalent values
 * but for \f$n\f$ incremented by one. When \f$x\f$ falls below a
 * small order-dependent cutoff, where the recursion is unreliable,
 * \f$j_{n}(x)\f$ is computed directly using a power series.
 *
 * @param jnm1 \f$j_{n-1}(x)\f$;
 * @param jn \f$j_{n}(x)\f$;
 * @param x argument of spherical Bessel function;
 * @param n order of spherical Bessel function
 *
 * @return 0 on success
 *
 */
 gint wbfmm_bessel_j_recursion_f(gfloat *jnm1,
						    gfloat *jn,
						    gfloat x, gint n) {}

/**
 *
 * @ingroup util
 *
 * @brief Initialize the spherical Bessel function recursion
 *
 * @param x argument of \f$j_{n}(x)\f$;
 * @param j0 on exit \f$j_{0}(x)\f$;
 * @param j1 on exit \f$j_{1}(x)\f$
 *
 * @return 0 on success
 *
 */

 gint wbfmm_bessel_j_init_f(gfloat x,
					       gfloat *j0, gfloat *j1)
 {}

 /**
 *
 * @ingroup util
 *
 * @brief Initialize spherical Hankel function recursion
 *
 * @param x argument of \f$h_{n}(x)\f$;
 * @param h0 on exit \f$h_{0}(x)\f$;
 * @param h1 on exit \f$h_{1}(x)\f$
 *
 * @return 0 on success
 *
 */
 gint wbfmm_bessel_h_init_f(gfloat x,
					       gfloat *h0,
					       gfloat *h1) {}

/**
 *
 * @ingroup util
 *
 * @brief Perform one step of spherical Hankel recursion
 *
 * Perform one step of the spherical Hankel function recursion. On
 * entry \a hnm1 and \a hnm contain \f$h_{n-1}(x)\f$ and
 * \f$h_{n}(x)\f$ respectively. On exit they contain equivalent values
 * but for \f$n\f$ incremented by one. When \f$x\f$ falls below a
 * small order-dependent cutoff, where the recursion is unreliable,
 * \f$h_{n}(x)\f$ is computed directly using a power series.
 *
 * @param hnm1 \f$h_{n-1}(x)\f$;
 * @param hn \f$h_{n}(x)\f$;
 * @param x argument of spherical Hankel function;
 * @param n order of spherical Hankel function
 *
 * @return 0 on success
 *
 */
 gint wbfmm_bessel_h_recursion_f(gfloat *hnm1,
						    gfloat *hn,
						    gfloat x, gint n) {}

/**
 *
 * @ingroup util
 *
 * @brief Compute total field from dipole sources by direct evaluation
 *
 * Evaluate the field at some point \f$\mathbf{x}\f$ by direct
 * evaluation of the sum over sources at \f$\mathbf{x}_{n}\f$
 * \f$\sum_{n=1}^{N}\mathbf{f}_{n}.\nabla 
 * h_{0}(\mathbf{x}-\mathbf{x}_{n})/4\pi\f$.
 * 
 *
 * @param k wavenumber;
 * @param xs array of source positions;
 * @param xstride stride in \a xs between source positions;
 * @param src array of complex vector source strengths;
 * @param sstride stride in \a src;
 * @param nsrc number of sources;
 * @param xf point for field evaluation;
 * @param field incremented with computed field
 *
 * @return 0 on success
 *
 */

 gint wbfmm_total_dipole_field_f(gfloat k,
						    gfloat *xs,
						    gint xstride,
						    gfloat *src,
						    gint sstride,
						    gint nsrc,
						    gfloat *xf,
						    gfloat *field) {}
   
/**
 *
 * @ingroup util
 *
 * @brief Compute total field by direct evaluation
 *
 * Evaluate the field at some point \f$\mathbf{x}\f$ by direct
 * evaluation of the sum over sources at \f$\mathbf{x}_{n}\f$
 * \f$\sum_{n=1}^{N}s_{n}h_{0}(\mathbf{x}-\mathbf{x}_{n})/4\pi\f$.
 *
 * @param k wavenumber;
 * @param xs array of source positions;
 * @param xstride stride in \a xs between source positions;
 * @param src array of complex scalar source strengths;
 * @param sstride stride in \a src;
 * @param nq number of source elements;
 * @param nsrc number of sources;
 * @param xf point for field evaluation;
 * @param field incremented with computed field;
 * @param fstr stride in field array between components.
 *
 * @return 0 on success
 *
 */
gint wbfmm_total_field_f(gfloat k, gfloat
					    *xs, gint xstride, gfloat
					    *src, gint sstride, gint nq,
					    gint nsrc,
					    gfloat *xf, gfloat
					    *field) {}

/**
 *
 * @ingroup util
 *
 * @brief Transform coordinates to rotated axes
 *
 * @param x point coordinates in original axes;
 * @param ix unit vector in new axes;
 * @param iy unit vector in new axes;
 * @param iz unit vector in new axes;
 * @param y point coordinates in new axes
 *
 * @return 0 on success
 *
 */

 gint wbfmm_coordinate_transform_f(gfloat *x,
						      gfloat *ix,
						      gfloat *iy,
						      gfloat *iz,
						      gfloat *y) {}

 /**
 *
 * @ingroup util
 *
 * @brief Find system of axes for coordinate shift
 *
 * @param x origin of shift;
 * @param y point to shift to;
 * @param ix on output unit vector of shift axes;
 * @param iy on output unit vector of shift axes;
 * @param iz on output unit vector of shift axes in direction of shift;
 * @param r distance between two input points
 *
 * @return 0 on success
 *
 */

 gint wbfmm_shift_coordinates_f(gfloat *x,
						   gfloat *y,
						   gfloat *ix,
						   gfloat *iy,
						   gfloat *iz,
						   gfloat *r) {}

 /**
 *
 * @ingroup util
 *
 * @brief Find the coordinates of a box from its Morton index
 *
 * @param idx Morton index of box;
 * @param level level in octree of box;
 * @param x0 origin of top-level box;
 * @param D width of top-level box;
 * @param x coordinates of box \a idx at level \a level;
 * @param wb width of box at level \a level
 *
 * @return 0 on success
 *
 */
 gint wbfmm_box_location_from_index_f(guint64 idx,
							 guint32 level,
							 gfloat *x0,
							 gfloat D,
							 gfloat *x,
							 gfloat *wb) {}

/**
 *
 * @ingroup util
 *
 * @brief Find centre and width of box in an octree
 *
 * @param t an octree;
 * @param level level inside \a t;
 * @param b Morton index of box at level \a level;
 * @param xb centre of box with index \a b at level \a level;
 * @param wb width of box at level \a level;
 *
 * @return 0 on success
 *
 */

 gint wbfmm_tree_box_centre_f(wbfmm_tree_t *t, guint32 level,
						 guint64 b, gfloat *xb,
						 gfloat *wb) {}

/**
 *
 * @ingroup util
 *
 * @brief Find limits of a cube containing a set of points
 *
 * @param x array of points coordinates;
 * @param str stride of points in \a x;
 * @param n number of points in \a x;
 * @param xmin origin of cube containing all points in \a x;
 * @param D width of cube containing all points in \a x;
 * @param init_limits if TRUE initialize limits overwriting any data in xmin
 *
 * @return 0 on success
 *
 */
 gint wbfmm_points_origin_width_f(gfloat *x,
						     gint str, gint n,
						     gfloat *xmin,
						     gfloat *D,
						     gboolean init_limits) {}

/**
 *
 * @ingroup util
 *
 * @brief Compute angles and distance to shift expansion between two points
 *
 * This is a combination of a call to
 * ::wbfmm_shift_coordinates_f(...) and 
 * ::wbfmm_rotation_angles_f(...)
 *
 * @param xi origin of shift;
 * @param xj destination of shift;
 * @param th \f$\theta\f$ for shift;
 * @param ph \f$\phi\f$ for shift;
 * @param ch \f$\chi\f$ for shift;
 * @param r  distance between source and destination points
 *
 * @return 0 on success
 *
 */

 gint wbfmm_shift_angles_f(gfloat *xi, gfloat *xj,
					      gfloat *th, gfloat *ph,
					      gfloat *ch, gfloat *r) {}

 /**
 *
 * @ingroup util
 *
 * @brief Write a tree source list to file
 *
 * Write to file a list of source positions attached to an octree, in
 * order of Morton index by which they are attached to leaf boxes. If
 * source strengths are supplied (\a q not NULL) these are also
 * written to file.
 *
 * @param t an octree with a list of sources attached;
 * @param q source strengths (if NULL, source strengths are not written);
 * @param stride source strength stride in \a q;
 * @param f output file to write to
 *
 * @return 0 on success
 *
 */
 gint wbfmm_tree_write_sources_f(wbfmm_tree_t *t,
						    gfloat *q, gint stride,
						    FILE *f) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Generation of singular expansion coefficients for point
 * source in Laplace problem
 *
 * @param N order of expansion;
 * @param x0 origin of expansion;
 * @param xs source position;
 * @param q  source strength(s);
 * @param nq number of components in \a q;
 * @param cfft on output, incremented with coefficients of expansion;
 * @param cstr stride in \a cfft (must be at least equal to \a nq);
 * @param work workspace.
 *
 * @return 0 on success
 *
 */
gint wbfmm_laplace_expansion_cfft_f(gint N,
						       gfloat *x0,
						       gfloat *xs,
						       gfloat *q, gint nq,
						       gfloat *cfft,
						       gint cstr,
							gfloat *work) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Evaluate a singular expansion for Laplace problem
 *
 * @param x0 origin of expansion;
 * @param cfft on output, incremented with coefficients of expansion;
 * @param cstr stride in \a cfft (must be at least equal to \a nq);
 * @param N order of expansion;
 * @param nq number of components in \a q;
 * @param xf field point;
 * @param field computed potential for each of the \a nq components;
 * @param work workspace.
 *
 * @return 0 on success
 *
 */

gint wbfmm_expansion_laplace_evaluate_f(gfloat *x0,
							   gfloat *cfft,
							   gint cstr, gint N,
							   gint nq,
							   gfloat *xf,
							   gfloat *field,
							   gfloat *work) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Evaluate the gradient of a singular expansion for Laplace problem
 *
 * @param x0 origin of expansion;
 * @param cfft on output, incremented with coefficients of expansion;
 * @param cstr stride in \a cfft (must be at least equal to \a nq);
 * @param N order of expansion;
 * @param nq number of components in \a q;
 * @param xf field point;
 * @param field computed potential for each of the \a nq components;
 * @param fstr stride in \a field
 * @param work workspace.
 *
 * @return 0 on success
 *
 */

gint wbfmm_expansion_laplace_grad_evaluate_f(gfloat *x0,
								gfloat *cfft,
								gint cstr, gint N,
								gint nq,
								gfloat *xf,
								gfloat *field,
								gint fstr,
								gfloat *work) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Singular to singular translation for Laplace expansion
 *
 * Translate a singular expansion for the Laplace problem along the
 * \f$z\f$ axis to a singular expansion about a new centre.  Before
 * any Laplace translation function is called, the translation
 * coefficients must be initialized with a call to
 * ::wbfmm_laplace_coaxial_translate_init_f(...)
 *
 * @param Co on output, expansion about new centre;
 * @param cstro stride in \a Co;
 * @param No order of expansion in \a Co;
 * @param Ci input expansion coefficients;
 * @param cstri stride in \a Ci;
 * @param Ni order of expansion in \a Ci;
 * @param nq number of source terms in expansion;
 * @param t distance to translate expansion.
 * 
 * @return 0 on success
 *
 **/

gint wbfmm_laplace_coaxial_translate_SS_f(gfloat *Co,
							     gint cstro,
							     gint No,
							     gfloat *Ci,
							     gint cstri,
							     gint Ni,
							     gint nq,
							     gfloat t) {}

/** 
 * 
 * @ingroup laplace
 *
 * @brief Upward shift of singular expansion from eight children to 
 * common parent in Laplace problem
 *
 * Shift the expansion of eight child boxes to their parent and sum
 * into the parent expansion. This function assumes data are packed
 * with a stride of eight elements so that all expansion coefficients
 * of a given order are contiguous in memory, ordered by Morton index. 
 *
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param nq number of elements in source;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param H47 rotation coefficients for `upper' children (Morton index 4-7);
 * @param Lh maximum order of rotation coefficients;
 * @param wb child box width;
 * @param work workspace
 *
 * @return 0 on success
 */

gint wbfmm_laplace_child_parent_shift_f(gfloat *Cp,
							   gint Np,
							   gfloat *Cc,
							   gint Nc,
							   gint nq,
							   gfloat *H03, 
							   gfloat *H47,
							   gint Lh,
							   gfloat wb,
							   gfloat *work) {}

/** 
 * 
 * @ingroup laplace
 *
 * @brief Upward shift of singular expansion from eight children to 
 * common parent in Laplace problem
 *
 * Shift the expansion of eight child boxes to their parent and sum
 * into the parent expansion. This function assumes data are packed
 * with a stride of eight elements so that all expansion coefficients
 * of a given order are contiguous in memory, ordered by Morton index,
 * using the backward translation method of
 * ::wbfmm_child_parent_shift_bw_f(...)
 *
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param nq number of elements in source;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param Lh maximum order of rotation coefficients;
 * @param wb child box width;
 * @param work workspace
 *
 * @return 0 on success
 */

gint wbfmm_laplace_child_parent_shift_bw_f(gfloat *Cp,
							      gint Np,
							      gfloat *Cc,
							      gint Nc,
							      gint nq,
							      gfloat *H03, 
							      gint Lh,
							      gfloat wb,
							      gfloat
							      *work) {} ;

/** 
 * 
 * @ingroup laplace
 *
 * @brief Downward shift of regular expansion from parent to eight
 * children in Laplace problem
 *
 * Shift the expansion of a parent box to its eight child boxes. This
 * function assumes data are packed with a stride of eight elements so
 * that all expansion coefficients of a given order are contiguous in
 * memory, ordered by Morton index. Note that rotation coefficients \a
 * H03 and \a H47 are the same as for the upward pass but switched
 * (because the rotations are performed in the opposite direction).
 *
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param nq number of elements in source;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param H47 rotation coefficients for `upper' children (Morton index 4-7);
 * @param Lh maximum order of rotation coefficients;
 * @param wb parent box width;
 * @param work workspace
 *
 * @return 0 on success
 */

gint wbfmm_laplace_parent_child_shift_f(gfloat *Cc,
							   gint Nc,
							   gfloat *Cp,
							   gint Np,
							   gint nq,
							   gfloat *H03, 
							   gfloat *H47,
							   gint Lh,
							   gfloat wb,
							   gfloat *work) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Generate coefficients for evaluation of field from
 * (singular) expansion coefficients in the Laplace problem. The
 * coefficients from this function can be applied to an expansion
 * using ::wbfmm_laplace_expansion_apply_f(...)
 * 
 * @param x location of evaluation point relative to centre of expansion;
 * @param N order of expansion;
 * @param grad if TRUE generate coefficients for gradient of field;
 * @param cfft on exit contains evaluation coefficients;
 * @param work workspace.
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_field_coefficients_f(gfloat *x,
							   gint N,
							   gboolean grad,
							   gfloat *cfft,
							   gfloat *work) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Apply evaluation coefficients to coefficients of an
 * expansion to evaluate the Laplace potential. Evaluation
 * coefficients can be evaluated using
 * wbfmm_laplace_field_coefficients) or
 * wbfmm_laplace_local_coefficients) for the field
 * (singular) or local (regular) expansions respectively.
 * 
 * @param C coefficients of expansion;
 * @param cstr stride in \a C;
 * @param nq number of source terms in \a C;
 * @param ec evaluation coefficients;
 * @param N order of expansion;
 * @param f on exit contains evaluated field.
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_expansion_apply_f(gfloat *C,
							gint cstr,
							gint nq,
							gfloat *ec,
							gint N,
							gfloat *f) {}

/** 
 * 
 * @ingroup laplace
 *
 * @brief Generate coefficients for evaluation of local field from
 * (regular) expansion coefficients in the Laplace problem. The
 * coefficients from this function can be applied to an expansion
 * using ::wbfmm_laplace_expansion_apply_f(...)
 * 
 * @param x location of evaluation point relative to centre of expansion;
 * @param N order of expansion;
 * @param grad if TRUE generate coefficients for gradient of field;
 * @param cfft on exit contains evaluation coefficients;
 * @param work workspace.
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_local_coefficients_f(gfloat *x,
							   gint N,
							   gboolean grad,
							   gfloat *cfft,
							   gfloat *work) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Evaluate local Laplace field from regular expansion in box
 *
 * @param t octree for domain;
 * @param level level of \a t;
 * @param b box index at level \a level of \a t;
 * @param x location of evaluation point;
 * @param f on output, field value (not zeroed before evaluation);
 * @param src source strengths;
 * @param sstr stride of data in \a src;
 * @param normals normals for dipole sources;
 * @param nstr stride in \a normals;
 * @param d dipole source strengths, or dipole vectors;
 * @param dstr stride in \a d;
 * @param eval_neighbours if TRUE compute contributions from sources 
 * in box \a b and neighbours; 
 * @param work workspace.
 *
 * @return 0 on success
 */

gint wbfmm_tree_laplace_box_local_field_f(wbfmm_tree_t *t,
							     guint level,
							     guint b,
							     gfloat *x,
							     gfloat *f,
							     gfloat *src,
							     gint sstr,
							     gfloat
							     *normals,
							     gint nstr,
							     gfloat *d,
							     gint dstr,
							     gboolean
							     eval_neighbours,
							     gfloat *work) {}

/** 
 * 
 * @ingroup laplace
 *
 * @brief Evaluate the Laplace field generated by all boxes on a given
 * level of an octree
 * 
 * @param t octree;
 * @param level level at which to use expansions;
 * @param xf field evaluation point;
 * @param field on output contains the sum of singular expansions from 
 * each box on level \a level evaluated at \a xf;
 * @param work workspace.
 *
 * @return 0 on success
 *
*/

gint wbfmm_box_fields_laplace_f(wbfmm_tree_t *t,
						   gint level,
						   gfloat *xf,
						   gfloat *field,
						   gfloat *work) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Generate leaf expansions for a tree in the Laplace problem
 *
 * Generate leaf expansions for a tree for the Laplace problem given
 * some combination of monopole and dipole sources. Source positions
 * are those in the point list attached to the tree using
 * ::wbfmm_tree_add_points_f(...) and indexing in
 * the array must correspond to that in the point list. Input arrays
 * may be NULL: if \a src is not NULL, it is interpreted as a list of
 * monopole strengths; if \a normals is not NULL, \a dipoles may not
 * be NULL and they are interpreted respectively as a vector
 * (`normal') at each source position and a scalar amplitude (this
 * corresponds to surface normal and a normal velocity amplitude in a
 * boundary element method calculation); if \a normals is NULL and \a
 * dipoles is not NULL, \a dipoles is interpreted as a three-element
 * vector specifying the dipole strength. The strides \a sstr, \a
 * nstr, and \a dstr are the number of scalar elements between
 * successive entries in the arrays, with the elements of each entry
 * densely packed. For example, a list of normals might read:
 *
 * \f$[n_{x1}\quad n_{y1}\quad n_{z1}\quad a_{1}\quad b_{1}\quad n_{x2}
 * \ldots]\f$
 *
 * where \f$(n_{x1},n_{y1},n_{z1})\f$ is the first normal vector and
 * \f$a_{1}\f$ and \f$b_{1}\f$ are arbitrary entries in the array. In
 * this case, the stride \a nstr would be 5, the number of elements
 * between successive values of \f$n_{xi}\f$. 
 *
 * @param t octree for problem;
 * @param src monopole source strengths;
 * @param sstr stride of data in \a src;
 * @param normals dipole normals;
 * @param nstr stride of data in \a normals;
 * @param dipoles dipole source strengths (if \a normals is not NULL), or 
 * moment vectors (if \a normals is NULL);
 * @param dstr stride of data in \a dipoles;
 * @param zero_expansions if TRUE, set expansion coefficients to zero
 * before adding source terms;
 * @param work workspace.
 *
 * @return 0 on success
 */

gint wbfmm_tree_laplace_leaf_expansions_f(wbfmm_tree_t *t,
							     gfloat *src,
							     gint sstr,
							     gfloat
							     *normals,
							     gint nstr,
							     gfloat
							     *dipoles,
							     gint dstr,
							     gboolean
							     zero_expansions,
							     gfloat *work) {}

gint wbfmm_tree_laplace_coefficient_init_f(wbfmm_tree_t *t,
							      guint l, 
							      guint nr,
							      guint ns) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Initialize lookup tables of Laplace translation coefficients 
 *
 * Initialize lookup tables of Laplace translation coefficients for use
 * in coaxial translation of Laplace expansions. This function must be
 * called before any coaxial translation is performed in a Laplace
 * problem.
 * 
 * @param N maximum order of expansion to be translated.
 *
 * @return 0 on success
 *
 */

 gint wbfmm_laplace_coaxial_translate_init_f(gint N) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Singular to regular translation for Laplace expansion
 *
 * Translate a singular expansion for the Laplace problem along
 * the \f$z\f$ axis to a regular expansion about a new centre. Before
 * any Laplace translation function is called, the translation
 * coefficients must be initialized with a call to
 * ::wbfmm_laplace_coaxial_translate_init_f(...)
 *
 * @param Co on output, expansion about new centre;
 * @param cstro stride in \a Co;
 * @param No order of expansion in \a Co;
 * @param Ci input expansion coefficients;
 * @param cstri stride in \a Ci;
 * @param Ni order of expansion in \a Ci;
 * @param nq number of source terms in expansion;
 * @param t distance to translate expansion.
 * 
 * @return 0 on success
 *
 **/

gint wbfmm_laplace_coaxial_translate_SR_f(gfloat *Co,
							     gint cstro,
							     gint No,
							     gfloat *Ci,
							     gint cstri,
							     gint Ni,
							     gint nq,
							     gfloat t) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Regular to regular translation for Laplace expansion
 *
 * Translate a regular expansion for the Laplace problem along
 * the \f$z\f$ axis to a regular expansion about a new centre. Before
 * any Laplace translation function is called, the translation
 * coefficients must be initialized with a call to
 * ::wbfmm_laplace_coaxial_translate_init_f(...)
 *
 * @param Co on output, expansion about new centre;
 * @param cstro stride in \a Co;
 * @param No order of expansion in \a Co;
 * @param Ci input expansion coefficients;
 * @param cstri stride in \a Ci;
 * @param Ni order of expansion in \a Ci;
 * @param nq number of source terms in expansion;
 * @param t distance to translate expansion.
 * 
 * @return 0 on success
 *
 **/

gint wbfmm_laplace_coaxial_translate_RR_f(gfloat *Co,
							     gint cstro,
							     gint No,
							     gfloat *Ci,
							     gint cstri,
							     gint Ni,
							     gint nq,
							     gfloat t) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Direct evaluation of the Laplace field from a list of sources
 * 
 * @param xs source positions
 * @param xstride source array stride
 * @param src source strengths
 * @param sstride source strength array stride
 * @param nq number of source components
 * @param normals normals at source positions
 * @param nstr normal stride
 * @param dipoles dipole components
 * @param dstr dipole stride
 * @param nsrc number of sources
 * @param xf field point
 * @param field on output incremented with computed field
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_field_grad_f(gfloat *xs, gint xstride,
						   gfloat *src, gint sstride,
						   gint nq,
						   gfloat *normals, gint nstr,
						   gfloat *dipoles, gint dstr,
						   gint nsrc,
						   gfloat *xf, gfloat *field) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Direct evaluation of the gradient of a Laplace field from a
 * list of sources
 * 
 * @param xs source positions
 * @param xstride source array stride
 * @param src source strengths
 * @param sstride source strength array stride
 * @param nq number of source components
 * @param normals normals at source positions
 * @param nstr normal stride
 * @param dipoles dipole components
 * @param dstr dipole stride
 * @param nsrc number of sources
 * @param xf field point
 * @param field on output incremented with computed field
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_field_f(gfloat *xs, gint xstride,
					      gfloat *src, gint sstride,
					      gint nq,
					      gfloat *normals, gint nstr,
					      gfloat *dipoles, gint dstr,
					      gint nsrc,
					      gfloat *xf, gfloat *field) {}


gint wbfmm_laplace_coaxial_translate_RR_f(gfloat *Co,
							     gint cstro,
							     gint No,
							     gfloat *Ci,
							     gint cstri,
							     gint Ni,
							     gint nq,
							     gfloat t) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Direct evaluation of the Laplace from a list of sources
 * 
 * @param xs source positions
 * @param xstride source array stride
 * @param src source strengths
 * @param sstride source strength array stride
 * @param nq number of source components
 * @param normals normals at source positions
 * @param nstr normal stride
 * @param dipoles dipole components
 * @param dstr dipole stride
 * @param nsrc number of sources
 * @param xf field point
 * @param field on output incremented with computed field
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_field_f(gfloat *xs, gint xstride,
					      gfloat *src, gint sstride,
					      gint nq,
					      gfloat *normals, gint nstr,
					      gfloat *dipoles, gint dstr,
					      gint nsrc,
					      gfloat *xf, gfloat *field) {}


/** 
 *
 * @ingroup laplace
 *
 * @brief 
 * 
 * @param 
 * @param 
 * @param 
 * @param 
 * @param 
 * @param 
 *
 * @return 0 on success
 *
*/

gint wbfmm_laplace_expansion_local_evaluate_f(gfloat *x0,
								 gfloat
								 *cfft,
								 gint cstr, 
								 gint N,
								 gint nq,
								 gfloat *xf,
								 gfloat
								 *field,
								 gfloat
								 *work) {}

/**
 * @ingroup rotations
 * @brief Apply rotation \f$(\theta,\phi\,\chi)\f$ to multipole
 * coefficients for the Laplace problem
 * 
 * Given the rotation coefficients \a H for angle \f$\theta\f$ from 
 * ::wbfmm_coefficients_H_rotation_f(...), rotate input
 * coefficients to new system of axes, using \a H and angles
 * \f$\phi\f$ and \f$\chi\f$. Input and output are strided arrays of
 * dense complex data with spacing between adjacent complex values
 * given as \a cstri and \a cstro elements respectively. Thus, \a Co for
 * example is packed as:
 *
 * \f$[\Re(C_{00})\quad \Im(C_{00}) \ldots (2\times\mbox{cstro})
 * \ldots \Re(C_{0,-1})\quad \Im(C_{0,-1})]\f$
 *
 * This stride system allows for packing data more conveniently for
 * upward and downward passes in the FMM proper. 
 *
 * @param Co on output contains rotated coefficients;
 * @param cstro stride in \a Co, in number of complex elements;
 * @param Ci input coefficients, to be rotated;
 * @param cstri stride in \a Ci, in number of complex elements;
 * @param N maximum order of coefficients;
 * @param nq number of source terms;
 * @param H rotation coefficients for angle \f$\theta\f$, from
 * ::wbfmm_coefficients_H_rotation_f(...);
 * @param ph angle \f$\phi\f$ for rotation;
 * @param ch angle \f$\chi\f$ for rotation.
 *
 * @return 0 on success
 */

gint wbfmm_laplace_rotate_H_f(gfloat *Co, gint cstro,
						 gfloat *Ci, gint cstri,
						 gint N, gint nq,
						 gfloat *H,
						 gfloat ph, gfloat ch) {}

 /**
 *
 * @ingroup pass
 *
 * @brief Perform downward pass at one level of an octree for the
 * Laplace problem
 *
 * Perform one stage of a downward pass for tree levels greater than
 * or equal to two. The actions performed are the evaluation of the
 * list 4 contribution to the regular expansion and, for non-leaf
 * boxes, a downward shift of the regular expansions to the child
 * boxes at the next level.
 *
 * @param t an initialized octree which has had the upward pass performed;
 * @param op shift operators allocated for \a t;
 * @param level level at which to perform downward pass;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_laplace_downward_pass_f(wbfmm_tree_t *t,
						      wbfmm_shift_operators_t
						      *op,
						      guint level,
						      gfloat *work) {}
/**
 *
 * @ingroup pass
 *
 * @brief Perform upward pass at one level of an octree for the
 * Laplace problem
 *
 * Perform one stage of the upward pass in an octree. The action
 * performed is the upward shift of the singular expansions from boxes
 * at level \a level to their parents. 
 *
 * @param t an initialized octree;
 * @param op shift operators allocated for \a t;
 * @param level level at which to perform upward pass;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint wbfmm_laplace_upward_pass_f(wbfmm_tree_t *t,
						    wbfmm_shift_operators_t *op,
						    guint level,
						    gfloat *work) {}
