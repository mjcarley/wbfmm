/** 
 * @ingroup boxes
 *
 * @brief Add points to an octree
 *
 * Add a set of source points to an octree. The points are assumed to
 * be in an array of real values with components in a packed triple,
 * indexed using a stride of pstr bytes (this allows for quite general
 * handling of different source formats). 
 * 
 * @param t an existing ::wbfmm_tree_t;
 * @param pts an array containing point coordinates;
 * @param npts the number of points in \a pts;
 * @param pstr stride between points in bytes.
 * 
 * @return 0 on success.
 */

gint WBFMM_FUNCTION_NAME(wbfmm_tree_add_points)(wbfmm_tree_t *t, 
						gpointer pts, guint npts,
						gsize pstr) {}

/** 
 * @ingroup rotations
 * @brief Compute the rotation angles \f$(\theta,\phi,\chi)\f$ between axes
 *
 * Compute the angles for rotation between two systems of axes 
 * \f$(\mathbf{i}_{x}, \mathbf{i}_{y}, \mathbf{i}_{z})\f$ and
 * \f$(\mathbf{j}_{x}, \mathbf{j}_{y}, \mathbf{j}_{z})\f$, as
 *  defined in Section 5 of Gumerov and Duraiswami. All vectors
 * should be unit length and form a right-handed coordinate system 
 * (no check is performed).
 * 
 * @param ix initial coordinate system \f$x\f$ axis;
 * @param iy initial coordinate system \f$y\f$ axis;
 * @param iz initial coordinate system \f$z\f$ axis;
 * @param jx rotated coordinate system \f$x\f$ axis;
 * @param jy rotated coordinate system \f$y\f$ axis;
 * @param jz rotated coordinate system \f$z\f$ axis;
 * @param th on exit, \f$\theta\f$ for rotation;
 * @param ph on exit, \f$\phi\f$ for rotation;
 * @param ch on exit, \f$\chi\f$ for rotation.
 * 
 * @return 0 on success
 */

gint WBFMM_FUNCTION_NAME(wbfmm_rotation_angles)(WBFMM_REAL *ix, WBFMM_REAL *iy,
						WBFMM_REAL *iz, WBFMM_REAL *jx,
						WBFMM_REAL *jy, WBFMM_REAL *jz,
						WBFMM_REAL *th, WBFMM_REAL *ph,
						WBFMM_REAL *ch) {}

/**
 * @ingroup rotations
 * @brief Compute rotation coefficients for angle \f$\theta\f$
 *
 * Generate the coefficients required to rotate one multipole
 * expansion to a new orientation, using Gumerov and Duraiswami,
 * Section 5, equation (5.48) and recursion (5.55). Coefficients \a H
 * are real and densely packed on output.
 *
 * @param H on output rotation coefficients;
 * @param N maximum order of coefficients to compute;
 * @param th rotation angle \f$\theta\f$, from 
 * ::WBFMM_FUNCTION_NAME(wbfmm_rotation_angles)(...);
 * @param work workspace
 *
 * @return 0 on success
 */
 gint WBFMM_FUNCTION_NAME(wbfmm_coefficients_H_rotation)(WBFMM_REAL *H,
							 gint N, WBFMM_REAL th,
							 WBFMM_REAL *work) {}
 
/**
 * @ingroup rotations
 * @brief Apply rotation \f$(\theta,\phi\,\chi)\f$ to multipole
 * coefficients
 * 
 * Given the rotation coefficients \a H for angle \f$\theta\f$ from 
 * ::WBFMM_FUNCTION_NAME(wbfmm_coefficients_H_rotation)(...), rotate input
 * coefficients to new system of axes, using \a H and angles
 * \f$\phi\f$ and \f$\chi\f$. Input and output are strided arrays of
 * dense complex data with spacing between adjacent complex values
 * given as \a cstri and \a cstro elements respectively. Thus, \a Co for
 * example is packed as:
 *
 * \f$[\Re(C_{00})\quad \Im(C_{00}) \ldots (2\times\mbox{cstro})
 * \ldots \Re(C_{0,-1})\quad \Im(C_{0,-1})]\f$
 *
 * This stride system allows for packing data more conveniently for
 * upward and downward passes in the FMM proper. 
 *
 * The function is available as a reference version
 * WBFMM_FUNCTION_NAME(wbfmm_rotate_H_ref)(...) and an optimized version
 * WBFMM_FUNCTION_NAME(wbfmm_rotate_H_avx)(...) which uses AVX
 * optimizations if available. The compile time switch -DWBFMM_USE_AVX
 * selects the AVX version. 
 *
 * @param Co on output contains rotated coefficients;
 * @param cstro stride in \a Co, in number of complex elements;
 * @param Ci input coefficients, to be rotated;
 * @param cstri stride in \a Ci, in number of complex elements;
 * @param N maximum order of coefficients;
 * @param H rotation coefficients for angle \f$\theta\f$, from
 * ::WBFMM_FUNCTION_NAME(wbfmm_coefficients_H_rotation)(...);
 * @param ph angle \f$\phi\f$ for rotation;
 * @param ch angle \f$\chi\f$ for rotation.
 *
 * @return 0 on success
 */

gint WBFMM_FUNCTION_NAME(wbfmm_rotate_H)(WBFMM_REAL *Co, gint cstro,
					 WBFMM_REAL *Ci, gint cstri,
					 gint N, WBFMM_REAL *H, WBFMM_REAL ph,
					 WBFMM_REAL ch) {}

/**     
 * @fn gint WBFMM_FUNCTION_NAME(wbfmm_coefficients_RR_coaxial)(WBFMM_REAL
 * *cfftRR, gint L, WBFMM_REAL kr, WBFMM_REAL *work)
 *
 * @ingroup translations
 *
 * @brief Generate coefficients for coaxial regular-to-regular translation
 *
 * Generate translation coefficients for a regular-to-regular coaxial
 * shift along the \f$z\f$ axis of the local coordinate system, by
 * distance \f$r\f$ for wavenumber \f$k\f$, using the methods of
 * Section 4.8 of Gumerov and Duraiswami. The regular-to-regular
 * translation coefficients are identical to the singular-to-singular
 * coefficients and are real.
 *
 * @param cfftRR on output contains (real) translation coefficients;
 * @param L maximum order of multipole expansion to be translated;
 * @param kr coaxial translation parameter (wavenumber times distance);
 * @param work workspace
 * 
 * @return 0 on success
 */


/**
 *
 * @ingroup translations
 *
 * @brief Generate coefficients for coaxial singular-to-regular translation
 *
 * Generate translation coefficients for a singular-to-regular coaxial
 * shift along the \f$z\f$ axis of the local coordinate system, by
 * distance \f$r\f$ for wavenumber \f$k\f$, using the methods of
 * Section 4.8 of Gumerov and Duraiswami. The output coefficients are
 * complex.
 *
 * @param cfftSR on output contains (complex) translation coefficients;
 * @param L maximum order of multipole expansion to be translated;
 * @param kr coaxial translation parameter (wavenumber times distance);
 * @param work workspace
 *
 * @return 0 on success
 */

gint WBFMM_FUNCTION_NAME(wbfmm_coefficients_SR_coaxial)(WBFMM_REAL *cfftSR, 
							gint L, WBFMM_REAL kr,
							WBFMM_REAL *work) {}


/**
 *
 * @ingroup translations
 *
 * @brief Perform coaxial translation of multipole expansion
 *
 * Compute the coaxial translation of a multipole expansion along its
 * \f$z\f$ axis, using coefficients from
 * ::WBFMM_FUNCTION_NAME(wbfmm_coefficients_SR_coaxial)(...) (complex) or
 * ::WBFMM_FUNCTION_NAME(wbfmm_coefficients_RR_coaxial)(...) (real). Input
 * and output coefficients are strided data as described for
 * ::WBFMM_FUNCTION_NAME(wbfmm_rotate_H)(...).
 *
 * @param Co on output contains translated multipole expansion;
 * @param cstro stride for output data in number of complex elements;
 * @param No order of output expansion;
 * @param Ci input multipole expansion;
 * @param cstri stride for input data in number of complex elements;
 * @param Ni order of input expansion;
 * @param cfft translation coefficients;
 * @param L maximum order of translation coefficients;
 * @param complex if TRUE treat \a cfft as complex
 * (e.g. for singular-to-regular translation); if FALSE treat as real
 * (e.g. regular-to-regular or singular-to-singular).
 *
 * @return 0 on success
 */
 gint WBFMM_FUNCTION_NAME(wbfmm_coaxial_translate)(WBFMM_REAL *Co,
						   gint cstro, gint No,
						   WBFMM_REAL *Ci,
						   gint cstri, gint Ni,
						   WBFMM_REAL *cfft,
						   gint L, gboolean complex) {}
 
/**
 *
 * @ingroup boxes
 *
 * @brief Allocate a new octree
 *
 * @param x location of origin of tree;
 * @param D width of domain;
 * @param maxpoints maximum number of source points in tree.
 *
 * @return pointer to newly allocated tree.
 */
 wbfmm_tree_t *WBFMM_FUNCTION_NAME(wbfmm_tree_new)(WBFMM_REAL *x,
						   WBFMM_REAL D,
						   guint maxpoints) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Generate leaf expansions for a tree
 *
 * Generate leaf expansions for a tree given some combination of
 * monopole and dipole sources. Source positions are those in the
 * point list attached to the tree using
 * ::WBFMM_FUNCTION_NAME(wbfmm_tree_add_points)(...) and indexing in the
 * array must correspond to that in the point list. Input arrays may
 * be NULL: if \a src is not NULL, it is interpreted as a list of
 * complex monopole strengths; if \a normals is not NULL, \a dipoles
 * may not be NULL and they are interpreted respectively as a vector
 * (`normal') at each source position and a scalar complex amplitude
 * (this corresponds to surface normal and a normal velocity amplitude
 * in a boundary element method calculation); if \a normals is NULL
 * and \a dipoles is not NULL, \a dipoles is interpreted as a
 * three-element complex vector specifying the dipole strength. The
 * strides \a sstr, \a nstr, and \a dstr are the number of scalar
 * elements between successive entries in the arrays, with the
 * elements of each entry densely packed. For example, a list of
 * normals might read:
 *
 * \f$[n_{x1}\quad n_{y1}\quad n_{z1}\quad a_{1}\quad b_{1}\quad n_{x2}
 * \ldots]\f$
 *
 * where \f$(n_{x1},n_{y1},n_{z1})\f$ is the first normal vector and
 * \f$a_{1}\f$ and \f$b_{1}\f$ are arbitrary entries in the array. In
 * this case, the stride \a nstr would be 5, the number of elements
 * between successive values of \f$n_{xi}\f$. 
 *
 * @param t octree for problem;
 * @param k wavenumber;
 * @param src monopole source strengths;
 * @param sstr stride of data in \a src;
 * @param normals dipole normals;
 * @param nstr stride of data in \a normals;
 * @param dipoles dipole source strengths (if \a normals is not NULL), or 
 * moment vectors (if \a normals is NULL);
 * @param dstr stride of data in \a dipoles;
 * @param zero_expansions if TRUE, set expansion coefficients to zero
 * before adding source terms;
 * @param work workspace.
 *
 * @return 0 on success
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_tree_leaf_expansions)(wbfmm_tree_t *t,
						      WBFMM_REAL k,
						      WBFMM_REAL *src,
						      gint sstr, 
						      WBFMM_REAL *normals,
						      gint nstr,
						      WBFMM_REAL *dipoles,
						      gint dstr,
						      gboolean zero_expansions,
						      WBFMM_REAL *work) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Evaluate singular expansion about a box centre
 *
 * @param t octree for problem;
 * @param level level in \a t;
 * @param b index of box at level \a level of \a t; 
 * @param k wavenumber;
 * @param x field evaluation point;
 * @param f on output field at \a x (not zeroed before evaluation);
 * @param work workspace
 *
 * @return 0 on success
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_tree_box_field)(wbfmm_tree_t *t, guint
						level, guint b, WBFMM_REAL k,
						WBFMM_REAL *x, WBFMM_REAL *f,
						WBFMM_REAL *work) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Evaluate local field from regular expansion in box
 *
 * @param t octree for domain;
 * @param level level of \a t;
 * @param b box index at level \a level of \a t;
 * @param k wavenumber;
 * @param x location of evaluation point;
 * @param f on output, field value (not zeroed before evaluation);
 * @param src source strengths;
 * @param sstr stride of data in \a src;
 * @param eval_neighbours if TRUE compute contributions from sources 
 * in box \a b and neighbours; 
 * @param work workspace.
 *
 * @return 0 on success
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_tree_box_local_field)(wbfmm_tree_t *t,
 guint level, guint b, WBFMM_REAL k, WBFMM_REAL *x, WBFMM_REAL *f,
 WBFMM_REAL *src, gint sstr, gboolean eval_neighbours, WBFMM_REAL
						      *work) {}


/**
 *
 * @ingroup boxes
 *
 * @brief Find Morton index for point in a cubic domain
 *
 * @param x point in space (three components, densely packed);
 * @param c location of bottom left corner of domain;
 * @param D width of domain.
 *
 * @return 0 on success
 */

 guint64 WBFMM_FUNCTION_NAME(wbfmm_point_index_3d)(WBFMM_REAL *x,
						   WBFMM_REAL *c,
						   WBFMM_REAL D) {}

/**
 *
 * @ingroup boxes 
 *
 * @brief Initialize expansion coefficient data in an octree
 *
 * @param t octree for problem;
 * @param l level to initialize data for;
 * @param nr order of regular expansions at level \a l;
 * @param ns order of singular expansions at level \a l.
 *
 * @return 0 on success
 */

gint WBFMM_FUNCTION_NAME(wbfmm_tree_coefficient_init)(wbfmm_tree_t
						      *t, guint l, guint nr,
						      guint ns) {}

/** 
 *
 * @ingroup boxes
 *
 * @brief
 *
 * Refine an existing octree by adding a level and redistributing
 * points attached to the tree to the boxes at the new level.
 * 
 * @param t an existing ::wbfmm_tree_t.
 * 
 * @return 0 on success.
 */

gint WBFMM_FUNCTION_NAME(wbfmm_tree_refine)(wbfmm_tree_t *t) {}

/**
 *
 * @ingroup shift
 *
 * @brief Upward shift of singular expansion from eight children to 
 * common parent
 *
 * Shift the expansion of eight child boxes to their parent and sum
 * into the parent expansion. This function assumes data are packed
 * with a stride of eight elements so that all expansion coefficients
 * of a given order are contiguous in memory, ordered by Morton index. 
 *
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param H47 rotation coefficients for `upper' children (Morton index 4-7);
 * @param Lh maximum order of rotation coefficients;
 * @param trans coaxial translation operator for distance between child and 
 * parent box centres;
 * @param Ls order of \a trans;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint WBFMM_FUNCTION_NAME(wbfmm_child_parent_shift)(WBFMM_REAL *Cp, gint Np,
						   WBFMM_REAL *Cc, gint Nc,
						   WBFMM_REAL *H03, 
						   WBFMM_REAL *H47, gint Lh,
						   WBFMM_REAL *trans, gint Ls,
						   WBFMM_REAL *work) {}

/**
 *
 * @ingroup shift
 *
 * @brief Upward shift of singular expansion from eight children to 
 * common parent, using backward translations
 *
 * Shift the expansion of eight child boxes to their parent and sum
 * into the parent expansion. This function assumes data are packed
 * with a stride of eight elements so that all expansion coefficients
 * of a given order are contiguous in memory, ordered by Morton
 * index. The method is the same as for
 * ::WBFMM_FUNCTION_NAME(wbfmm_child_parent_shift)(...), except that
 * the child boxes with Morton indices 4-7 are rotated in the same
 * sense as the diagonally opposite child boxes 0-3 and a reverse
 * (negative distance) coaxial translation is used to combine them
 * with the lower child box data with the same rotation. The reverse
 * rotation is then applied to the summed data meaning that only four
 * reverse rotations rather than eight are required to transfer the
 * data to the parent box orientation.
 *
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param Lh maximum order of rotation coefficients;
 * @param transf forward (\f$+kr\f$) coaxial translation operator for 
 * distance between child and parent box centres;
 * @param transb backward (\f$-kr\f$) coaxial translation operator for 
 * distance between child and parent box centres;
 * @param Ls order of \a trans;
 * @param work workspace
 *
 * @return 0 on success
 *
 */


gint WBFMM_FUNCTION_NAME(wbfmm_child_parent_shift_bw)(WBFMM_REAL *Cp, gint Np,
						      WBFMM_REAL *Cc, gint Nc,
						      WBFMM_REAL *H03, gint Lh,
						      WBFMM_REAL *transf,
						      WBFMM_REAL *transb,
						      gint Ls,
						      WBFMM_REAL *work) {}

/**
 *
 * @ingroup shift
 *
 * @brief Downward shift of parent expansion to child box centres
 *
 * Shift the (regular) expansion data from a parent box to each of its
 * child boxes, assuming the same packing as in
 * ::WBFMM_FUNCTION_NAME(wbfmm_child_parent_shift)(...). Note that the
 * rotation matrices for this function are switched relative to the
 * rotations of the same name in
 * ::WBFMM_FUNCTION_NAME(wbfmm_child_parent_shift)(...), because the `upper'
 * children rotate `down' to be shifted to the parent centre but the
 * rotation is `up' to shift from the parent to those children, and
 * similarly for the `lower' children.
 *
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param H47 rotation coefficients for `upper' children (Morton index 4-7);
 * @param Lh maximum order of rotation coefficients;
 * @param trans coaxial translation operator for distance between child and 
 * parent box centres;
 * @param Ls order of \a trans;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

  gint WBFMM_FUNCTION_NAME(wbfmm_parent_child_shift)(WBFMM_REAL *Cc, gint Nc,
						   WBFMM_REAL *Cp, gint Np,
						   WBFMM_REAL *H03, 
						   WBFMM_REAL *H47, gint Lh,
						   WBFMM_REAL *trans, gint Ls,
						   WBFMM_REAL *work) {}

/**
 * @ingroup shift
 *
 * @brief Extract the rotation angles for boxes on interaction list 4
 *
 * Find the rotation angles \f$(\theta,\phi\,\chi)\f$ between a box at
 * integer coordinates \f$(i,j,k)\f$, using a look-up table which
 * should be initialized with
 * ::WBFMM_FUNCTION_NAME(wbfmm_shift_angle_table_init)(...)
 *
 * @param i integer \f$x\f$ coordinate of box on interaction list;
 * @param j integer \f$y\f$ coordinate of box on interaction list;
 * @param k integer \f$z\f$ coordinate of box on interaction list;
 * @param th \f$\theta\f$ for rotation between boxes;
 * @param ph \f$\phi\f$ for rotation between boxes;
 * @param ch \f$\chi\f$ for rotation between boxes;
 * @param rs scaling factor for distance between box centres, distance
 * is \a rs multiplied by box width.
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_shift_angles_list4)(gint i, gint j, gint k,
					     WBFMM_REAL *th, WBFMM_REAL *ph,
					     WBFMM_REAL *ch, WBFMM_REAL *rs) {} 

/**
 *
 * @ingroup shift
 *
 * @brief Initialize table of angles for shift operations
 *
 * This function must be called before any interaction calculations
 * are performed, in particular before any call to
 * ::WBFMM_FUNCTION_NAME(wbfmm_shift_operators_new)(...), in order to
 * initialize the look-up table of orientations between boxes in
 * interaction lists.
 *
 *
 * @return 0 on success
 *
 */

gint WBFMM_FUNCTION_NAME(wbfmm_shift_angle_table_init)(void) {}
 
/**
 *
 * @ingroup shift 
 *
 * @brief Allocate shift operators and initialize rotations
 *
 * Allocate a new ::wbfmm_shift_operators_t of given maximum order and
 * initialize the rotation coefficients needed for same-level
 * interaction calculations and upward and downward passes.
 *
 * @param L maximum order of expansions;
 * @param bw if TRUE generate operators for backward translation algorithm;
 * @param work workspace.
 *
 * @return 0 on success
 *
 */

wbfmm_shift_operators_t
WBFMM_FUNCTION_NAME(*wbfmm_shift_operators_new)(guint L,
						gboolean bw,
						WBFMM_REAL *work) {}

/**
 *
 * @ingroup shift
 *
 * @brief Initialize singular-to-regular translation operators
 *
 * @param w a ::wbfmm_shift_operators_t allocated with 
 * WBFMM_FUNCTION_NAME(wbfmm_shift_operators_new)(...);
 * @param D width of the problem domain;
 * @param level level for which to generate translations;
 * @param L order of translations;
 * @param k wavenumber;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint WBFMM_FUNCTION_NAME(wbfmm_shift_operators_coaxial_SR_init)
     (wbfmm_shift_operators_t *w, WBFMM_REAL D, guint level, guint L,
      WBFMM_REAL k, WBFMM_REAL *work) {}

/**
 *
 * @ingroup shift
 *
 * @brief Initialize singular-to-singular (regular-to-regular)
 * translation operators
 *
 * @param w a ::wbfmm_shift_operators_t allocated with 
 * WBFMM_FUNCTION_NAME(wbfmm_shift_operators_new)(...);
 * @param D width of the problem domain;
 * @param level level for which to generate translations;
 * @param L order of translations;
 * @param k wavenumber;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_shift_operators_coaxial_SS_init)
     (wbfmm_shift_operators_t *w, WBFMM_REAL D, guint level, 
      guint L, WBFMM_REAL k, WBFMM_REAL *work) {}

 /**
 *
 * @ingroup expansions
 *
 * @brief Generation of singular expansion coefficients for point source
 *
 * @param k wavenumber;
 * @param N order of expansion;
 * @param x0 centre of expansion;
 * @param xs source position;
 * @param q complex source strength;
 * @param cfft incremented with expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_expansion_h_cfft)(WBFMM_REAL k, gint N, 
                                                  WBFMM_REAL *x0,
						  WBFMM_REAL *xs,
						  WBFMM_REAL *q, 
						  WBFMM_REAL *cfft, gint cstr,
						  WBFMM_REAL *work) {}

 /**
 *
 * @ingroup expansions
 *
 * @brief Generation of singular expansion coefficients for point dipole source
 *
 * @param k wavenumber;
 * @param N order of expansion;
 * @param x0 centre of expansion;
 * @param xs source position;
 * @param fx component of complex source strength;
 * @param fy component of complex source strength;
 * @param fz component of complex source strength;
 * @param cfft incremented with expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_expansion_dipole_h_cfft)(WBFMM_REAL k, gint N, 
						  WBFMM_REAL *x0,
						  WBFMM_REAL *xs,
						  WBFMM_REAL *fx,
						  WBFMM_REAL *fy,
						  WBFMM_REAL *fz,
						  WBFMM_REAL *cfft, gint cstr,
							 WBFMM_REAL *work) {}

/**
 *
 * @ingroup expansions
 *
 * @brief Evaluate a singular expansion
 *
 * @param k wavenumber;
 * @param x0 centre of expansion;
 * @param cfft expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param N order of expansion;
 * @param xf field point;
 * @param field incremented with computed field;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint WBFMM_FUNCTION_NAME(wbfmm_expansion_h_evaluate)(WBFMM_REAL k, 
                                                      WBFMM_REAL *x0,
						      WBFMM_REAL *cfft,
						      gint cstr,
						      gint N, 
						      WBFMM_REAL *xf, 
						      WBFMM_REAL *field,
						     WBFMM_REAL *work) {}

/**
 *
 * @ingroup expansions
 *
 * @brief Evaluate a regular expansion
 *
 * @param k wavenumber;
 * @param x0 centre of expansion;
 * @param cfft expansion coefficients;
 * @param cstr stride in \a cfft, in number of complex elements;
 * @param N order of expansion;
 * @param xf field point;
 * @param field incremented with computed field;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_expansion_j_evaluate)(WBFMM_REAL k,
                                                      WBFMM_REAL *x0,
						      WBFMM_REAL *cfft,
						      gint cstr,
						      gint N, 
						      WBFMM_REAL *xf, 
						      WBFMM_REAL *field,
						      WBFMM_REAL *work) {}

 /**
 *
 * @ingroup pass
 *
 * @brief Perform downward pass at one level of an octree
 *
 * Perform one stage of a downward pass for tree levels greater than
 * or equal to two. The actions performed are the evaluation of the
 * list 4 contribution to the regular expansion and, for non-leaf
 * boxes, a downward shift of the regular expansions to the child
 * boxes at the next level.
 *
 * @param t an initialized octree which has had the upward pass performed;
 * @param op shift operators allocated for \a t;
 * @param level level at which to perform downward pass;
 * @param work workspace
 *
 * @return 0 on success
 *
 */
 gint WBFMM_FUNCTION_NAME(wbfmm_downward_pass)(wbfmm_tree_t *t,
					       wbfmm_shift_operators_t *op,
					       guint level, WBFMM_REAL *work) {}

/**
 *
 * @ingroup pass
 *
 * @brief Perform upward pass at one level of an octree
 *
 * Perform one stage of the upward pass in an octree. The action
 * performed is the upward shift of the singular expansions from boxes
 * at level \a level to their parents. 
 *
 * @param t an initialized octree;
 * @param op shift operators allocated for \a t;
 * @param level level at which to perform upward pass;
 * @param work workspace
 *
 * @return 0 on success
 *
 */
 gint WBFMM_FUNCTION_NAME(wbfmm_upward_pass)(wbfmm_tree_t *t,
					     wbfmm_shift_operators_t *op,
					     guint level, WBFMM_REAL *work) {}

/**
 *
 * @ingroup util
 *
 * @brief Convert Cartesian to spherical coordinates \f$(r,\theta,\phi)\f$
 *
 * @param x0 centre of coordinate system;
 * @param x point whose coordinates are to be found;
 * @param r \f$r\f$;
 * @param th \f$\theta\f$;
 * @param ph \f$\phi\f$
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_cartesian_to_spherical)(WBFMM_REAL
							*x0, WBFMM_REAL *x,
							WBFMM_REAL *r,
							WBFMM_REAL *th,
							WBFMM_REAL *ph) {}

/**
 *
 * @ingroup util
 *
 * @brief Perform recursion on normalized associated Legendre functions
 *
 * Perform recursion on normalized associated Legendre functions with
 * input \f$P_{n-1}^{m}(\cos\theta)\f$, \f$0\leq m\leq n-1\f$, and
 * \f$P_{n}^{m}(\cos\theta)\f$, \f$0\leq m \leq n\f$, generating
 * equivalent outputs with \f$n\f$ incremented by one. Note that the
 * arrays of associated Legendre functions are switched internally to
 * ensure that the ordering remains correct after the recursion step. 
 *
 * @param Pnm1 pointer to array of normalized associated Legendre functions
 * for \f$n-1\f$;
 * @param Pn pointer to array of normalized associated Legendre functions 
 * for \f$n\f$;
 * @param n order of \a Pn;
 * @param C \f$\cos\theta\f$;
 * @param S \f$\sin\theta\f$;
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_legendre_recursion_array)(WBFMM_REAL **Pnm1,
							  WBFMM_REAL **Pn,
							  gint n,
							  WBFMM_REAL C,
							  WBFMM_REAL S) {}

 /**
 *
 * @ingroup util
 *
 * @brief Initialize normalized associated Legendre functions
 *
 * @param C \f$\cos\theta\f$;
 * @param S \f$\sin\theta\f$;
 * @param P0 on output \f$P_{0}^{0}(\cos\theta)\f$;
 * @param P10 on output \f$P_{1}^{0}(\cos\theta)\f$;
 * @param P11 on output \f$P_{1}^{1}(\cos\theta)\f$;
 *
 * @return 0 on success
 *
 */
 gint WBFMM_FUNCTION_NAME(wbfmm_legendre_init)(WBFMM_REAL C, WBFMM_REAL S, 
					       WBFMM_REAL *P0, WBFMM_REAL *P10,
					       WBFMM_REAL *P11) {}

/**
 *
 * @ingroup util
 *
 * @brief Perform recursion on spherical Bessel function \f$j_{n}(x)\f$
 *
 * Perform one step of the spherical Bessel function recursion. On
 * entry \a jnm1 and \a jnm contain \f$j_{n-1}(x)\f$ and
 * \f$j_{n}(x)\f$ respectively. On exit they contain equivalent values
 * but for \f$n\f$ incremented by one. When \f$x\f$ falls below a
 * small order-dependent cutoff, where the recursion is unreliable,
 * \f$j_{n}(x)\f$ is computed directly using a power series.
 *
 * @param jnm1 \f$j_{n-1}(x)\f$;
 * @param jn \f$j_{n}(x)\f$;
 * @param x argument of spherical Bessel function;
 * @param n order of spherical Bessel function
 *
 * @return 0 on success
 *
 */
 gint WBFMM_FUNCTION_NAME(wbfmm_bessel_j_recursion)(WBFMM_REAL *jnm1,
						    WBFMM_REAL *jn,
						    WBFMM_REAL x, gint n) {}

/**
 *
 * @ingroup util
 *
 * @brief Initialize the spherical Bessel function recursion
 *
 * @param x argument of \f$j_{n}(x)\f$;
 * @param j0 on exit \f$j_{0}(x)\f$;
 * @param j1 on exit \f$j_{1}(x)\f$
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_bessel_j_init)(WBFMM_REAL x,
					       WBFMM_REAL *j0, WBFMM_REAL *j1)
 {}

 /**
 *
 * @ingroup util
 *
 * @brief Initialize spherical Hankel function recursion
 *
 * @param x argument of \f$h_{n}(x)\f$;
 * @param h0 on exit \f$h_{0}(x)\f$;
 * @param h1 on exit \f$h_{1}(x)\f$
 *
 * @return 0 on success
 *
 */
 gint WBFMM_FUNCTION_NAME(wbfmm_bessel_h_init)(WBFMM_REAL x,
					       WBFMM_REAL *h0,
					       WBFMM_REAL *h1) {}

/**
 *
 * @ingroup util
 *
 * @brief Perform one step of spherical Hankel recursion
 *
 * Perform one step of the spherical Hankel function recursion. On
 * entry \a hnm1 and \a hnm contain \f$h_{n-1}(x)\f$ and
 * \f$h_{n}(x)\f$ respectively. On exit they contain equivalent values
 * but for \f$n\f$ incremented by one. When \f$x\f$ falls below a
 * small order-dependent cutoff, where the recursion is unreliable,
 * \f$h_{n}(x)\f$ is computed directly using a power series.
 *
 * @param hnm1 \f$h_{n-1}(x)\f$;
 * @param hn \f$h_{n}(x)\f$;
 * @param x argument of spherical Hankel function;
 * @param n order of spherical Hankel function
 *
 * @return 0 on success
 *
 */
 gint WBFMM_FUNCTION_NAME(wbfmm_bessel_h_recursion)(WBFMM_REAL *hnm1,
						    WBFMM_REAL *hn,
						    WBFMM_REAL x, gint n) {}

/**
 *
 * @ingroup util
 *
 * @brief Compute total field from dipole sources by direct evaluation
 *
 * Evaluate the field at some point \f$\mathbf{x}\f$ by direct
 * evaluation of the sum over sources at \f$\mathbf{x}_{n}\f$
 * \f$\sum_{n=1}^{N}\mathbf{f}_{n}.\nabla 
 * h_{0}(\mathbf{x}-\mathbf{x}_{n})/4\pi\f$.
 * 
 *
 * @param k wavenumber;
 * @param xs array of source positions;
 * @param xstride stride in \a xs between source positions;
 * @param src array of complex vector source strengths;
 * @param sstride stride in \a src;
 * @param nsrc number of sources;
 * @param xf point for field evaluation;
 * @param field incremented with computed field
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_total_dipole_field)(WBFMM_REAL k,
						    WBFMM_REAL *xs,
						    gint xstride,
						    WBFMM_REAL *src,
						    gint sstride,
						    gint nsrc,
						    WBFMM_REAL *xf,
						    WBFMM_REAL *field) {}
   
/**
 *
 * @ingroup util
 *
 * @brief Compute total field by direct evaluation
 *
 * Evaluate the field at some point \f$\mathbf{x}\f$ by direct
 * evaluation of the sum over sources at \f$\mathbf{x}_{n}\f$
 * \f$\sum_{n=1}^{N}s_{n}h_{0}(\mathbf{x}-\mathbf{x}_{n})/4\pi\f$.
 *
 * @param k wavenumber;
 * @param xs array of source positions;
 * @param xstride stride in \a xs between source positions;
 * @param src array of complex scalar source strengths;
 * @param sstride stride in \a src;
 * @param nsrc number of sources;
 * @param xf point for field evaluation;
 * @param field incremented with computed field
 *
 * @return 0 on success
 *
 */
gint WBFMM_FUNCTION_NAME(wbfmm_total_field)(WBFMM_REAL k, WBFMM_REAL
					    *xs, gint xstride, WBFMM_REAL
					    *src, gint sstride, gint nsrc,
					    WBFMM_REAL *xf, WBFMM_REAL
					    *field) {}

/**
 *
 * @ingroup util
 *
 * @brief Transform coordinates to rotated axes
 *
 * @param x point coordinates in original axes;
 * @param ix unit vector in new axes;
 * @param iy unit vector in new axes;
 * @param iz unit vector in new axes;
 * @param y point coordinates in new axes
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_coordinate_transform)(WBFMM_REAL *x,
						      WBFMM_REAL *ix,
						      WBFMM_REAL *iy,
						      WBFMM_REAL *iz,
						      WBFMM_REAL *y) {}

 /**
 *
 * @ingroup util
 *
 * @brief Find system of axes for coordinate shift
 *
 * @param x origin of shift;
 * @param y point to shift to;
 * @param ix on output unit vector of shift axes;
 * @param iy on output unit vector of shift axes;
 * @param iz on output unit vector of shift axes in direction of shift;
 * @param r distance between two input points
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_shift_coordinates)(WBFMM_REAL *x,
						   WBFMM_REAL *y,
						   WBFMM_REAL *ix,
						   WBFMM_REAL *iy,
						   WBFMM_REAL *iz,
						   WBFMM_REAL *r) {}

 /**
 *
 * @ingroup util
 *
 * @brief Find the coordinates of a box from its Morton index
 *
 * @param idx Morton index of box;
 * @param level level in octree of box;
 * @param x0 origin of top-level box;
 * @param D width of top-level box;
 * @param x coordinates of box \a idx at level \a level;
 * @param wb width of box at level \a level
 *
 * @return 0 on success
 *
 */
 gint WBFMM_FUNCTION_NAME(wbfmm_box_location_from_index)(guint64 idx,
							 guint32 level,
							 WBFMM_REAL *x0,
							 WBFMM_REAL D,
							 WBFMM_REAL *x,
							 WBFMM_REAL *wb) {}

/**
 *
 * @ingroup util
 *
 * @brief Find centre and width of box in an octree
 *
 * @param t an octree;
 * @param level level inside \a t;
 * @param b Morton index of box at level \a level;
 * @param xb centre of box with index \a b at level \a level;
 * @param wb width of box at level \a level;
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_tree_box_centre)(wbfmm_tree_t *t, guint32 level,
						 guint64 b, WBFMM_REAL *xb,
						 WBFMM_REAL *wb) {}

/**
 *
 * @ingroup util
 *
 * @brief Find limits of a cube containing a set of points
 *
 * @param x array of points coordinates;
 * @param str stride of points in \a x;
 * @param n number of points in \a x;
 * @param xmin origin of cube containing all points in \a x;
 * @param D width of cube containing all points in \a x;
 * @param init_limits if TRUE initialize limits overwriting any data in xmin
 *
 * @return 0 on success
 *
 */
 gint WBFMM_FUNCTION_NAME(wbfmm_points_origin_width)(WBFMM_REAL *x,
						     gint str, gint n,
						     WBFMM_REAL *xmin,
						     WBFMM_REAL *D,
						     gboolean init_limits) {}

/**
 *
 * @ingroup util
 *
 * @brief Compute angles and distance to shift expansion between two points
 *
 * This is a combination of a call to
 * ::WBFMM_FUNCTION_NAME(wbfmm_shift_coordinates)(...) and 
 * ::WBFMM_FUNCTION_NAME(wbfmm_rotation_angles)(...)
 *
 * @param xi origin of shift;
 * @param xj destination of shift;
 * @param th \f$\theta\f$ for shift;
 * @param ph \f$\phi\f$ for shift;
 * @param ch \f$\chi\f$ for shift;
 * @param r  distance between source and destination points
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_shift_angles)(WBFMM_REAL *xi, WBFMM_REAL *xj,
					      WBFMM_REAL *th, WBFMM_REAL *ph,
					      WBFMM_REAL *ch, WBFMM_REAL *r) {}

 /**
 *
 * @ingroup util
 *
 * @brief Write a tree source list to file
 *
 * Write to file a list of source positions attached to an octree, in
 * order of Morton index by which they are attached to leaf boxes. If
 * source strengths are supplied (\a q not NULL) these are also
 * written to file.
 *
 * @param t an octree with a list of sources attached;
 * @param q source strengths (if NULL, source strengths are not written);
 * @param stride source strength stride in \a q;
 * @param f output file to write to
 *
 * @return 0 on success
 *
 */
 gint WBFMM_FUNCTION_NAME(wbfmm_tree_write_sources)(wbfmm_tree_t *t,
						    WBFMM_REAL *q, gint stride,
						    FILE *f) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Generation of singular expansion coefficients for point
 * source in Laplace problem
 *
 * @param N order of expansion;
 * @param x0 origin of expansion;
 * @param xs source position;
 * @param q  source strength(s);
 * @param nq number of components in \a q;
 * @param cfft on output, incremented with coefficients of expansion;
 * @param cstr stride in \a cfft (must be at least equal to \a nq);
 * @param work workspace.
 *
 * @return 0 on success
 *
 */
gint WBFMM_FUNCTION_NAME(wbfmm_laplace_expansion_cfft)(gint N,
						       WBFMM_REAL *x0,
						       WBFMM_REAL *xs,
						       WBFMM_REAL *q, gint nq,
						       WBFMM_REAL *cfft,
						       gint cstr,
							WBFMM_REAL *work) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Evaluate a singular expansion for Laplace problem
 *
 * @param x0 origin of expansion;
 * @param cfft on output, incremented with coefficients of expansion;
 * @param cstr stride in \a cfft (must be at least equal to \a nq);
 * @param N order of expansion;
 * @param nq number of components in \a q;
 * @param xf field point;
 * @param field computed potential for each of the \a nq components;
 * @param work workspace.
 *
 * @return 0 on success
 *
 */

gint WBFMM_FUNCTION_NAME(wbfmm_expansion_laplace_evaluate)(WBFMM_REAL *x0,
							   WBFMM_REAL *cfft,
							   gint cstr, gint N,
							   gint nq,
							   WBFMM_REAL *xf,
							   WBFMM_REAL *field,
							   WBFMM_REAL *work) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Singular to singular translation for Laplace expansion
 *
 * Translate a singular expansion for the Laplace problem along the
 * \f$z\f$ axis to a singular expansion about a new centre.  Before
 * any Laplace translation function is called, the translation
 * coefficients must be initialized with a call to
 * ::WBFMM_FUNCTION_NAME(wbfmm_laplace_coaxial_translate_init)(...)
 *
 * @param Co on output, expansion about new centre;
 * @param cstro stride in \a Co;
 * @param No order of expansion in \a Co;
 * @param Ci input expansion coefficients;
 * @param cstri stride in \a Ci;
 * @param Ni order of expansion in \a Ci;
 * @param nq number of source terms in expansion;
 * @param t distance to translate expansion.
 * 
 * @return 0 on success
 *
 **/

gint WBFMM_FUNCTION_NAME(wbfmm_laplace_coaxial_translate_SS)(WBFMM_REAL *Co,
							     gint cstro,
							     gint No,
							     WBFMM_REAL *Ci,
							     gint cstri,
							     gint Ni,
							     gint nq,
							     WBFMM_REAL t) {}

/** 
 * 
 * @ingroup laplace
 *
 * @brief Upward shift of singular expansion from eight children to 
 * common parent in Laplace problem
 *
 * Shift the expansion of eight child boxes to their parent and sum
 * into the parent expansion. This function assumes data are packed
 * with a stride of eight elements so that all expansion coefficients
 * of a given order are contiguous in memory, ordered by Morton index. 
 *
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param nq number of elements in source;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param H47 rotation coefficients for `upper' children (Morton index 4-7);
 * @param Lh maximum order of rotation coefficients;
 * @param wb child box width;
 * @param work workspace
 *
 * @return 0 on success
 */

gint WBFMM_FUNCTION_NAME(wbfmm_laplace_child_parent_shift)(WBFMM_REAL *Cp,
							   gint Np,
							   WBFMM_REAL *Cc,
							   gint Nc,
							   gint nq,
							   WBFMM_REAL *H03, 
							   WBFMM_REAL *H47,
							   gint Lh,
							   WBFMM_REAL wb,
							   WBFMM_REAL *work) {}

/** 
 * 
 * @ingroup laplace
 *
 * @brief Upward shift of singular expansion from eight children to 
 * common parent in Laplace problem
 *
 * Shift the expansion of eight child boxes to their parent and sum
 * into the parent expansion. This function assumes data are packed
 * with a stride of eight elements so that all expansion coefficients
 * of a given order are contiguous in memory, ordered by Morton index,
 * using the backward translation method of
 * ::WBFMM_FUNCTION_NAME(wbfmm_child_parent_shift_bw)(...)
 *
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param nq number of elements in source;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param Lh maximum order of rotation coefficients;
 * @param wb child box width;
 * @param work workspace
 *
 * @return 0 on success
 */

gint WBFMM_FUNCTION_NAME(wbfmm_laplace_child_parent_shift_bw)(WBFMM_REAL *Cp,
							      gint Np,
							      WBFMM_REAL *Cc,
							      gint Nc,
							      gint nq,
							      WBFMM_REAL *H03, 
							      gint Lh,
							      WBFMM_REAL wb,
							      WBFMM_REAL
							      *work) {} ;

/** 
 * 
 * @ingroup laplace
 *
 * @brief Downward shift of regular expansion from parent to eight
 * children in Laplace problem
 *
 * Shift the expansion of a parent box to its eight child boxes. This
 * function assumes data are packed with a stride of eight elements so
 * that all expansion coefficients of a given order are contiguous in
 * memory, ordered by Morton index. Note that rotation coefficients \a
 * H03 and \a H47 are the same as for the upward pass but switched
 * (because the rotations are performed in the opposite direction).
 *
 * @param Cc child expansion array;
 * @param Nc order of child expansions;
 * @param Cp parent expansion array;
 * @param Np order of parent expansion;
 * @param nq number of elements in source;
 * @param H03 rotation coefficients for `lower' children (Morton index 0-3);
 * @param H47 rotation coefficients for `upper' children (Morton index 4-7);
 * @param Lh maximum order of rotation coefficients;
 * @param wb parent box width;
 * @param work workspace
 *
 * @return 0 on success
 */

gint WBFMM_FUNCTION_NAME(wbfmm_laplace_parent_child_shift)(WBFMM_REAL *Cc,
							   gint Nc,
							   WBFMM_REAL *Cp,
							   gint Np,
							   gint nq,
							   WBFMM_REAL *H03, 
							   WBFMM_REAL *H47,
							   gint Lh,
							   WBFMM_REAL wb,
							   WBFMM_REAL *work) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Generate coefficients for evaluation of field from
 * (singular) expansion coefficients in the Laplace problem. The
 * coefficients from this function can be applied to an expansion
 * using ::WBFMM_FUNCTION_NAME(wbfmm_laplace_expansion_apply)(...)
 * 
 * @param x location of evaluation point relative to centre of expansion;
 * @param N order of expansion;
 * @param grad if TRUE generate coefficients for gradient of field;
 * @param cfft on exit contains evaluation coefficients;
 * @param work workspace.
 *
 * @return 0 on success
 *
*/

gint WBFMM_FUNCTION_NAME(wbfmm_laplace_field_coefficients)(WBFMM_REAL *x,
							   gint N,
							   gboolean grad,
							   WBFMM_REAL *cfft,
							   WBFMM_REAL *work) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Apply evaluation coefficients to coefficients of an
 * expansion to evaluate the Laplace potential. Evaluation
 * coefficients can be evaluated using
 * WBFMM_FUNCTION_NAME(wbfmm_laplace_field_coefficients) or
 * WBFMM_FUNCTION_NAME(wbfmm_laplace_local_coefficients) for the field
 * (singular) or local (regular) expansions respectively.
 * 
 * @param C coefficients of expansion;
 * @param cstr stride in \a C;
 * @param nq number of source terms in \a C;
 * @param ec evaluation coefficients;
 * @param N order of expansion;
 * @param f on exit contains evaluated field.
 *
 * @return 0 on success
 *
*/

gint WBFMM_FUNCTION_NAME(wbfmm_laplace_expansion_apply)(WBFMM_REAL *C,
							gint cstr,
							gint nq,
							WBFMM_REAL *ec,
							gint N,
							WBFMM_REAL *f) {}

/** 
 * 
 * @ingroup laplace
 *
 * @brief Generate coefficients for evaluation of local field from
 * (regular) expansion coefficients in the Laplace problem. The
 * coefficients from this function can be applied to an expansion
 * using ::WBFMM_FUNCTION_NAME(wbfmm_laplace_expansion_apply)(...)
 * 
 * @param x location of evaluation point relative to centre of expansion;
 * @param N order of expansion;
 * @param grad if TRUE generate coefficients for gradient of field;
 * @param cfft on exit contains evaluation coefficients;
 * @param work workspace.
 *
 * @return 0 on success
 *
*/

gint WBFMM_FUNCTION_NAME(wbfmm_laplace_local_coefficients)(WBFMM_REAL *x,
							   gint N,
							   gboolean grad,
							   WBFMM_REAL *cfft,
							   WBFMM_REAL *work) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Evaluate local Laplace field from regular expansion in box
 *
 * @param t octree for domain;
 * @param level level of \a t;
 * @param b box index at level \a level of \a t;
 * @param x location of evaluation point;
 * @param f on output, field value (not zeroed before evaluation);
 * @param src source strengths;
 * @param sstr stride of data in \a src;
 * @param normals normals for dipole sources;
 * @param nstr stride in \a normals;
 * @param d dipole source strengths, or dipole vectors;
 * @param dstr stride in \a d;
 * @param eval_neighbours if TRUE compute contributions from sources 
 * in box \a b and neighbours; 
 * @param work workspace.
 *
 * @return 0 on success
 */

gint WBFMM_FUNCTION_NAME(wbfmm_tree_laplace_box_local_field)(wbfmm_tree_t *t,
							     guint level,
							     guint b,
							     WBFMM_REAL *x,
							     WBFMM_REAL *f,
							     WBFMM_REAL *src,
							     gint sstr,
							     WBFMM_REAL
							     *normals,
							     gint nstr,
							     WBFMM_REAL *d,
							     gint dstr,
							     gboolean
							     eval_neighbours,
							     WBFMM_REAL *work) {}

/** 
 * 
 * @ingroup laplace
 *
 * @brief Evaluate the Laplace field generated by all boxes on a given
 * level of an octree
 * 
 * @param t octree;
 * @param level level at which to use expansions;
 * @param xf field evaluation point;
 * @param field on output contains the sum of singular expansions from 
 * each box on level \a level evaluated at \a xf;
 * @param work workspace.
 *
 * @return 0 on success
 *
*/

gint WBFMM_FUNCTION_NAME(wbfmm_box_fields_laplace)(wbfmm_tree_t *t,
						   gint level,
						   WBFMM_REAL *xf,
						   WBFMM_REAL *field,
						   WBFMM_REAL *work) {}

/**
 *
 * @ingroup boxes
 *
 * @brief Generate leaf expansions for a tree in the Laplace problem
 *
 * Generate leaf expansions for a tree for the Laplace problem given
 * some combination of monopole and dipole sources. Source positions
 * are those in the point list attached to the tree using
 * ::WBFMM_FUNCTION_NAME(wbfmm_tree_add_points)(...) and indexing in
 * the array must correspond to that in the point list. Input arrays
 * may be NULL: if \a src is not NULL, it is interpreted as a list of
 * monopole strengths; if \a normals is not NULL, \a dipoles may not
 * be NULL and they are interpreted respectively as a vector
 * (`normal') at each source position and a scalar amplitude (this
 * corresponds to surface normal and a normal velocity amplitude in a
 * boundary element method calculation); if \a normals is NULL and \a
 * dipoles is not NULL, \a dipoles is interpreted as a three-element
 * vector specifying the dipole strength. The strides \a sstr, \a
 * nstr, and \a dstr are the number of scalar elements between
 * successive entries in the arrays, with the elements of each entry
 * densely packed. For example, a list of normals might read:
 *
 * \f$[n_{x1}\quad n_{y1}\quad n_{z1}\quad a_{1}\quad b_{1}\quad n_{x2}
 * \ldots]\f$
 *
 * where \f$(n_{x1},n_{y1},n_{z1})\f$ is the first normal vector and
 * \f$a_{1}\f$ and \f$b_{1}\f$ are arbitrary entries in the array. In
 * this case, the stride \a nstr would be 5, the number of elements
 * between successive values of \f$n_{xi}\f$. 
 *
 * @param t octree for problem;
 * @param src monopole source strengths;
 * @param sstr stride of data in \a src;
 * @param normals dipole normals;
 * @param nstr stride of data in \a normals;
 * @param dipoles dipole source strengths (if \a normals is not NULL), or 
 * moment vectors (if \a normals is NULL);
 * @param dstr stride of data in \a dipoles;
 * @param zero_expansions if TRUE, set expansion coefficients to zero
 * before adding source terms;
 * @param work workspace.
 *
 * @return 0 on success
 */

gint WBFMM_FUNCTION_NAME(wbfmm_tree_laplace_leaf_expansions)(wbfmm_tree_t *t,
							     WBFMM_REAL *src,
							     gint sstr,
							     WBFMM_REAL
							     *normals,
							     gint nstr,
							     WBFMM_REAL
							     *dipoles,
							     gint dstr,
							     gboolean
							     zero_expansions,
							     WBFMM_REAL *work) {}

gint WBFMM_FUNCTION_NAME(wbfmm_tree_laplace_coefficient_init)(wbfmm_tree_t *t,
							      guint l, 
							      guint nr,
							      guint ns) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief Initialize lookup tables of Laplace translation coefficients 
 *
 * Initialize lookup tables of Laplace translation coefficients for use
 * in coaxial translation of Laplace expansions. This function must be
 * called before any coaxial translation is performed in a Laplace
 * problem.
 * 
 * @param N maximum order of expansion to be translated.
 *
 * @return 0 on success
 *
 */

 gint WBFMM_FUNCTION_NAME(wbfmm_laplace_coaxial_translate_init)(gint N) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Singular to regular translation for Laplace expansion
 *
 * Translate a singular expansion for the Laplace problem along
 * the \f$z\f$ axis to a regular expansion about a new centre. Before
 * any Laplace translation function is called, the translation
 * coefficients must be initialized with a call to
 * ::WBFMM_FUNCTION_NAME(wbfmm_laplace_coaxial_translate_init)(...)
 *
 * @param Co on output, expansion about new centre;
 * @param cstro stride in \a Co;
 * @param No order of expansion in \a Co;
 * @param Ci input expansion coefficients;
 * @param cstri stride in \a Ci;
 * @param Ni order of expansion in \a Ci;
 * @param nq number of source terms in expansion;
 * @param t distance to translate expansion.
 * 
 * @return 0 on success
 *
 **/

gint WBFMM_FUNCTION_NAME(wbfmm_laplace_coaxial_translate_SR)(WBFMM_REAL *Co,
							     gint cstro,
							     gint No,
							     WBFMM_REAL *Ci,
							     gint cstri,
							     gint Ni,
							     gint nq,
							     WBFMM_REAL t) {}

/**
 *
 * @ingroup laplace
 *
 * @brief Regular to regular translation for Laplace expansion
 *
 * Translate a regular expansion for the Laplace problem along
 * the \f$z\f$ axis to a regular expansion about a new centre. Before
 * any Laplace translation function is called, the translation
 * coefficients must be initialized with a call to
 * ::WBFMM_FUNCTION_NAME(wbfmm_laplace_coaxial_translate_init)(...)
 *
 * @param Co on output, expansion about new centre;
 * @param cstro stride in \a Co;
 * @param No order of expansion in \a Co;
 * @param Ci input expansion coefficients;
 * @param cstri stride in \a Ci;
 * @param Ni order of expansion in \a Ci;
 * @param nq number of source terms in expansion;
 * @param t distance to translate expansion.
 * 
 * @return 0 on success
 *
 **/

gint WBFMM_FUNCTION_NAME(wbfmm_laplace_coaxial_translate_RR)(WBFMM_REAL *Co,
							     gint cstro,
							     gint No,
							     WBFMM_REAL *Ci,
							     gint cstri,
							     gint Ni,
							     gint nq,
							     WBFMM_REAL t) {}

/**
 * 
 * @ingroup laplace
 *
 * @brief 
 * 
 * @param 
 * @param 
 * @param 
 * @param 
 * @param 
 * @param 
 *
 * @return 0 on success
 *
*/
gint WBFMM_FUNCTION_NAME(wbfmm_laplace_field)(WBFMM_REAL *xs, gint xstride,
					      WBFMM_REAL *src, gint sstride,
					      gint nq,
					      WBFMM_REAL *normals, gint nstr,
					      WBFMM_REAL *dipoles, gint dstr,
					      gint nsrc,
					      WBFMM_REAL *xf, WBFMM_REAL *field) {}

/** 
 *
 * @ingroup laplace
 *
 * @brief 
 * 
 * @param 
 * @param 
 * @param 
 * @param 
 * @param 
 * @param 
 *
 * @return 0 on success
 *
*/

gint WBFMM_FUNCTION_NAME(wbfmm_laplace_expansion_local_evaluate)(WBFMM_REAL *x0,
								 WBFMM_REAL
								 *cfft,
								 gint cstr, 
								 gint N,
								 gint nq,
								 WBFMM_REAL *xf,
								 WBFMM_REAL
								 *field,
								 WBFMM_REAL
								 *work) {}

/**
 * @ingroup rotations
 * @brief Apply rotation \f$(\theta,\phi\,\chi)\f$ to multipole
 * coefficients for the Laplace problem
 * 
 * Given the rotation coefficients \a H for angle \f$\theta\f$ from 
 * ::WBFMM_FUNCTION_NAME(wbfmm_coefficients_H_rotation)(...), rotate input
 * coefficients to new system of axes, using \a H and angles
 * \f$\phi\f$ and \f$\chi\f$. Input and output are strided arrays of
 * dense complex data with spacing between adjacent complex values
 * given as \a cstri and \a cstro elements respectively. Thus, \a Co for
 * example is packed as:
 *
 * \f$[\Re(C_{00})\quad \Im(C_{00}) \ldots (2\times\mbox{cstro})
 * \ldots \Re(C_{0,-1})\quad \Im(C_{0,-1})]\f$
 *
 * This stride system allows for packing data more conveniently for
 * upward and downward passes in the FMM proper. 
 *
 * @param Co on output contains rotated coefficients;
 * @param cstro stride in \a Co, in number of complex elements;
 * @param Ci input coefficients, to be rotated;
 * @param cstri stride in \a Ci, in number of complex elements;
 * @param N maximum order of coefficients;
 * @param nq number of source terms;
 * @param H rotation coefficients for angle \f$\theta\f$, from
 * ::WBFMM_FUNCTION_NAME(wbfmm_coefficients_H_rotation)(...);
 * @param ph angle \f$\phi\f$ for rotation;
 * @param ch angle \f$\chi\f$ for rotation.
 *
 * @return 0 on success
 */

gint WBFMM_FUNCTION_NAME(wbfmm_laplace_rotate_H)(WBFMM_REAL *Co, gint cstro,
						 WBFMM_REAL *Ci, gint cstri,
						 gint N, gint nq,
						 WBFMM_REAL *H,
						 WBFMM_REAL ph, WBFMM_REAL ch) {}

 /**
 *
 * @ingroup pass
 *
 * @brief Perform downward pass at one level of an octree for the
 * Laplace problem
 *
 * Perform one stage of a downward pass for tree levels greater than
 * or equal to two. The actions performed are the evaluation of the
 * list 4 contribution to the regular expansion and, for non-leaf
 * boxes, a downward shift of the regular expansions to the child
 * boxes at the next level.
 *
 * @param t an initialized octree which has had the upward pass performed;
 * @param op shift operators allocated for \a t;
 * @param level level at which to perform downward pass;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint WBFMM_FUNCTION_NAME(wbfmm_laplace_downward_pass)(wbfmm_tree_t *t,
						      wbfmm_shift_operators_t
						      *op,
						      guint level,
						      WBFMM_REAL *work) {}
/**
 *
 * @ingroup pass
 *
 * @brief Perform upward pass at one level of an octree for the
 * Laplace problem
 *
 * Perform one stage of the upward pass in an octree. The action
 * performed is the upward shift of the singular expansions from boxes
 * at level \a level to their parents. 
 *
 * @param t an initialized octree;
 * @param op shift operators allocated for \a t;
 * @param level level at which to perform upward pass;
 * @param work workspace
 *
 * @return 0 on success
 *
 */

gint WBFMM_FUNCTION_NAME(wbfmm_laplace_upward_pass)(wbfmm_tree_t *t,
						    wbfmm_shift_operators_t *op,
						    guint level,
						    WBFMM_REAL *work) {}
