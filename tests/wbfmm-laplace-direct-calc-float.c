/* This file is part of WBFMM, a Wide-Band Fast Multipole Method code
 *
 * Copyright (C) 2019 Michael Carley
 *
 * WBFMM is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.  WBFMM is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with WBFMM.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <math.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include <glib.h>

#include <wbfmm.h>

#define BUFSIZE 131072

GTimer *timer ;
gchar *progname ;

gint read_points(gchar *file, gfloat **points, gint *nsrc, gint *str) ;

gint read_points(gchar *file, gfloat **points, gint *nsrc, gint *str)

{
  FILE *input = stdin ;
  gfloat *s ;
  gint i, j ;

  if ( file != NULL ) {
    input = fopen(file, "r") ;
    if ( input == NULL ) {
      fprintf(stderr, "%s: cannot open file %s\n", progname, file) ;
      exit(1) ;
    }
  }

  fscanf(input, "%d", nsrc) ;
  fscanf(input, "%d", str) ;
  fprintf(stderr, "%s: %d point%c; stride %d\n", 
	  progname, *nsrc, (*nsrc > 1 ? 's' : ' '), (*str)) ;
  s = *points = (gfloat *)g_malloc0((*str)*(*nsrc)*sizeof(gfloat)) ;

  for ( i = 0 ; i < *nsrc ; i ++ ) {
    for ( j = 0 ; j < *str ; j ++ ) 
      fscanf(input, "%g", &(s[(*str)*i+j])) ;
  }

  if ( file != NULL ) fclose(input) ;

  return 0 ;
}

gint main(gint argc, gchar **argv)

{
  gfloat *sources ;
  gfloat *xf, *f, *q ;
  gint nsrc, i, j, str, strf, nf, qstr, nq ;
  gchar ch, *sfile = NULL, *ffile = NULL ;

  progname = g_strdup(g_path_get_basename(argv[0])) ;
  timer = g_timer_new() ;

  nq = 1 ;
  while ( (ch = getopt(argc, argv, "hf:k:s:")) != EOF ) {
    switch ( ch ) {
    default:
    case 'h':
      fprintf(stderr,
	      "Usage: %s <options> > <output file>\n\n"
	      "Compute field generated by list of sources at specified "
	      "field points using\n"
	      "direct evaluation method\n"
	      "Options:\n\n"
	      "  -f (field point name)\n"
	      "  -s (source file name)\n",
	      progname) ;
      return 0 ;
      break ;
    case 'f': ffile = g_strdup(optarg) ; break ;      
    case 's': sfile = g_strdup(optarg) ; break ;
    }
  }

  if ( sfile != NULL ) {
    read_points(sfile, &sources, &nsrc, &str) ;
    switch ( str ) {
    default:
      fprintf(stderr, "%s: don't know how to interpret stride %d\n",
	      progname, str) ;
      exit(1) ;
      break ;
    case  4: fprintf(stderr, "%s: monopole sources\n", progname) ; break ;
    case  5: fprintf(stderr, "%s: monopole sources\n", progname) ; break ;
    case  8: fprintf(stderr, "%s: dipole sources\n", progname) ; break ;
    case 10: fprintf(stderr, "%s: mixed sources\n", progname) ; break ;
    }
  } else {
    fprintf(stderr, "%s: source list must be specified (-s)\n",
	    progname) ;
    return 1 ;
  }

  if ( ffile != NULL ) {
    read_points(ffile, &xf, &nf, &strf) ;
  } else {
    fprintf(stderr, "%s: field point list must be specified (-f)\n",
	    progname) ;
    return 1 ;
  }

  fprintf(stderr, "%s: computing direct field; %lg\n",
	  progname, g_timer_elapsed(timer, NULL)) ;

  q = &(sources[3]) ; qstr = str ; nq = str - 3 ;
  f = (gfloat *)g_malloc0(nf*nq*sizeof(gfloat)) ;

#if 0
  /*only monopole sources for now*/
  qstr = nstr = dstr = 0 ;
  q = normals = dipoles = NULL ;
  switch ( str ) {
  default: g_assert_not_reached() ; break ;
  case 5:
    q = &(sources[3]) ; qstr = str ;
    break ;
  case 8:
    normals = &(sources[3]) ; nstr = str ;
    dipoles = &(sources[6]) ; dstr = str ;
    break ;
  case 10:
    q = &(sources[3]) ; qstr = str ;
    normals = &(sources[4]) ; nstr = str ;
    dipoles = &(sources[8]) ; dstr = str ;
    break ;
  }

  for ( i = 0 ; i < nf ; i ++ ) {
    wbfmm_total_field_f(k, sources, str,
			   q, qstr, normals, nstr, dipoles, dstr, nsrc,
			   &(xf[i*strf]), &(f[2*i])) ;
  }
#endif

  for ( i = 0 ; i < nf ; i ++ ) {
    wbfmm_laplace_field_f(sources, str, q, qstr, nq, NULL, 0, NULL, 0,
			     nsrc, &(xf[i*strf]), &(f[nq*i])) ;
  }
  
  fprintf(stderr, "%s: direct field computed; %lg\n",
	  progname, g_timer_elapsed(timer, NULL)) ;

  for ( i = 0 ; i < nf ; i ++ ) {
    fprintf(stdout,
    	    "%1.16e %1.16e %1.16e",
    	    xf[i*strf+0], xf[i*strf+1], xf[i*strf+2]) ;
    for ( j = 0 ; j < nq ; j ++ ) {
      fprintf(stdout, " %1.16e", f[nq*i+j]) ;
    }
    fprintf(stdout, "\n") ;
  }

  return 0 ;
}
