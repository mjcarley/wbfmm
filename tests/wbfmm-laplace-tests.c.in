/* This file is part of WBFMM, a Wide-Band Fast Multipole Method code
 *
 * Copyright (C) 2019 Michael Carley
 *
 * WBFMM is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.  WBFMM is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with WBFMM.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <math.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include <glib.h>

#include <wbfmm.h>

#define BUFSIZE 131072

GTimer *timer ;

gchar *tests[] = {"expansion",
		  "translation",
		  ""} ;


static gint parse_test(gchar *arg)

{
  gint i = 0 ;
  
  while ( strlen(tests[i]) != 0) {
    if ( !strcmp(tests[i], arg) ) return i ;
    i ++ ;
  }

  return -1 ;
}

static gint read_data(gchar *ipfile, WBFMM_REAL *xc, WBFMM_REAL *x0, 
		      WBFMM_REAL **xs, WBFMM_REAL **src, 
		      gint *nsrc, gint *xstride, gint *sstride,
		      WBFMM_REAL **xf, gint *fstride, gint *nfld,
		      WBFMM_REAL *ix,WBFMM_REAL *iy, WBFMM_REAL *iz)

{
  FILE *f ;
  gchar line[1024] ;
  gint i ;

  f = fopen(ipfile, "r") ;
  if ( f == NULL ) {
    fprintf(stderr, "cannot open %s\n", ipfile) ;
    exit (1) ;
  }

  fprintf(stderr, "reading %s\n", ipfile) ;
  
  while ( fscanf(f, "%[^\n]c", line) != EOF ) {
    /* fprintf(stderr, "%s\n", line) ; */
    if ( strncmp(line, "x0:", 3) == 0 ) {
      fprintf(stderr, "x0: ") ;
      sscanf(&(line[3]), "%FLOATFMT %FLOATFMT %FLOATFMT", &(x0[0]), &(x0[1]), &(x0[2])) ;
      fprintf(stderr, "%FLOATFMT %FLOATFMT %FLOATFMT\n", x0[0], x0[1], x0[2]) ;
    }
    if ( strncmp(line, "xc:", 3) == 0 ) {
      fprintf(stderr, "xc: ") ;
      sscanf(&(line[3]), "%FLOATFMT %FLOATFMT %FLOATFMT", &(xc[0]), &(xc[1]), &(xc[2])) ;
      fprintf(stderr, "%FLOATFMT %FLOATFMT %FLOATFMT\n", xc[0], xc[1], xc[2]) ;
    }

    if ( strncmp(line, "ix:", 3) == 0 ) {
      fprintf(stderr, "ix: ") ;
      sscanf(&(line[3]), "%FLOATFMT %FLOATFMT %FLOATFMT", &(ix[0]), &(ix[1]), &(ix[2])) ;
      fprintf(stderr, "%FLOATFMT %FLOATFMT %FLOATFMT\n", ix[0], ix[1], ix[2]) ;
    }

    if ( strncmp(line, "iy:", 3) == 0 ) {
      fprintf(stderr, "iy: ") ;
      sscanf(&(line[3]), "%FLOATFMT %FLOATFMT %FLOATFMT", &(iy[0]), &(iy[1]), &(iy[2])) ;
      fprintf(stderr, "%FLOATFMT %FLOATFMT %FLOATFMT\n", iy[0], iy[1], iy[2]) ;
    }

    if ( strncmp(line, "iz:", 3) == 0 ) {
      fprintf(stderr, "iz: ") ;
      sscanf(&(line[3]), "%FLOATFMT %FLOATFMT %FLOATFMT", &(iz[0]), &(iz[1]), &(iz[2])) ;
      fprintf(stderr, "%FLOATFMT %FLOATFMT %FLOATFMT\n", iz[0], iz[1], iz[2]) ;
    }

    if ( strncmp(line, "sources:", 8) == 0 ) {
      fprintf(stderr, "source list: ") ;
      sscanf(&(line[8]), "%d", nsrc) ;
      fprintf(stderr, "%d source", *nsrc) ;
      fprintf(stderr, (*nsrc == 1 ? "\n" : "s\n")) ;
      *xstride = 3 ; *sstride = 2 ;
      *xs = (WBFMM_REAL *)g_malloc((*nsrc)*(*xstride)*sizeof(WBFMM_REAL)) ;
      *src = (WBFMM_REAL *)g_malloc((*nsrc)*(*sstride)*sizeof(WBFMM_REAL)) ;
      for ( i = 0 ; i < *nsrc ; i ++ ) {
	fscanf(f, "%FLOATFMT %FLOATFMT %FLOATFMT %FLOATFMT %FLOATFMT",
	       &((*xs)[(*xstride)*i+0]),
	       &((*xs)[(*xstride)*i+1]),
	       &((*xs)[(*xstride)*i+2]),
	       &((*src)[(*sstride)*i+0]),
	       &((*src)[(*sstride)*i+1])) ;
      }
    }
    if ( strncmp(line, "field:", 6) == 0 ) {
      fprintf(stderr, "field points: ") ;
      sscanf(&(line[6]), "%d", nfld) ;
      fprintf(stderr, "%d point", *nfld) ;
      fprintf(stderr, (*nfld == 1 ? "\n" : "s\n")) ;
      *fstride = 5 ;
      *xf = (WBFMM_REAL *)g_malloc((*nfld)*(*fstride)*sizeof(WBFMM_REAL)) ;
      for ( i = 0 ; i < *nfld ; i ++ ) {
	fscanf(f, "%FLOATFMT %FLOATFMT %FLOATFMT",
	       &((*xf)[(*fstride)*i+0]),
	       &((*xf)[(*fstride)*i+1]),
	       &((*xf)[(*fstride)*i+2])) ;
      }
    }

    fscanf(f, "%*c") ;
  }

  fprintf(stderr, "%s read\n", ipfile) ;

  fclose(f) ;

  return 0 ;
}

gint expansion_test(gint N, WBFMM_REAL *x0, WBFMM_REAL *xs,
		    gint xstride, WBFMM_REAL *src, gint sstride,
		    gint nsrc, WBFMM_REAL *xf, gint nfld)

{
  gint i, nq, cstr ;
  WBFMM_REAL cfft[16384]={0.0}, work[8192]={0.0}, fc[8]={0.0}, ff[8]={0.0} ;

  nq = 2 ;
  fprintf(stderr, "expansion test\n") ;
  fprintf(stderr, "==============\n") ;
  fprintf(stderr,
	  "N = %d\n"
	  "x0 = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "xf = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "nsrc = %d\n",
	  N, x0[0], x0[1], x0[2], xf[0], xf[1], xf[2], nsrc) ;

  /*reference calculation*/
  wbfmm_laplace_field_PREC(xs, xstride, src, sstride, nq, NULL, 0, NULL, 0,
			   nsrc, xf, fc) ;

  cstr = 2 ;
  /*multipole expansion*/
  for ( i = 0 ; i < nsrc ; i ++ ) 
    wbfmm_expansion_laplace_cfft_PREC(N, x0, &(xs[i*xstride]),
				      &(src[i*sstride]), nq, cfft, cstr,
				      work) ;

  wbfmm_expansion_laplace_evaluate_PREC(x0, cfft, cstr, nq, N, xf, ff, work) ;
  
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", fc[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", ff[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-ff[i])) ;
  fprintf(stderr, "\n") ;
  
  return 0 ;
}

gint translation_test(gint N, WBFMM_REAL *x0, WBFMM_REAL *xs,
		      gint xstride, WBFMM_REAL *src, gint sstride,
		      gint nsrc, WBFMM_REAL *xf, gint nfld, WBFMM_REAL t)

{
  gint i, nq, cstr ;
  WBFMM_REAL Ci[16384]={0.0}, work[8192]={0.0}, Co[16384]={0.0} ;
  WBFMM_REAL fc[8]={0.0}, ff[8]={0.0}, ft[8]={0.0} ;

  nq = 2 ;
  fprintf(stderr, "translation test\n") ;
  fprintf(stderr, "==============\n") ;
  fprintf(stderr,
	  "N = %d\n"
	  "x0 = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "xf = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "t  = %FLOATFMT\n"
	  "nsrc = %d\n",
	  N, x0[0], x0[1], x0[2], xf[0], xf[1], xf[2], t, nsrc) ;

  /*reference calculation*/
  wbfmm_laplace_field_PREC(xs, xstride, src, sstride, nq, NULL, 0, NULL, 0,
			   nsrc, xf, fc) ;

  cstr = 4 ;
  /*multipole expansion*/
  for ( i = 0 ; i < nsrc ; i ++ ) 
    wbfmm_expansion_laplace_cfft_PREC(N, x0, &(xs[i*xstride]),
				      &(src[i*sstride]), nq, Ci, cstr,
				      work) ;

  wbfmm_expansion_laplace_evaluate_PREC(x0, Ci, cstr, nq, N, xf, ff, work) ;

  /*translate the expansion*/
  wbfmm_coaxial_translate_laplace_PREC(Co, cstr, N, Ci, cstr, N, t, nq) ;

  x0[2] += t ;  
  wbfmm_expansion_laplace_evaluate_PREC(x0, Co, cstr, nq, N, xf, ft, work) ;
  
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", fc[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", ff[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-ff[i])) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", ft[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-ft[i])) ;
  fprintf(stderr, "\n") ;
  
  return 0 ;
}


gint main(gint argc, gchar **argv)

{
  WBFMM_REAL *xs, *src, *xf, wb ;
  WBFMM_REAL x, k, r, x0[3] = {0.0}, xc[3] = {0.0} ;
  WBFMM_REAL ix[3] = {0}, iy[3] = {0}, iz[3] = {0} ;
  gint nsrc, sstride, xstride, fstride, N, i, nfld, test, quad ;
  gchar ch, *ipfile ;
  guint level ;

  k = 2.0 ; N = 16 ; 
  sstride = 2 ; xstride = 3 ; 
  r = 0.25 ;
  nsrc = 1 ;
  nfld = 1 ;
  x = 0.025 ;
  test = -1 ;
  ipfile = NULL ;
  ix[0] = iy[1] = iz[2] = 1.0 ; 
  xs = src = xf = NULL ;
  quad = 0 ;
  wb = 1.0 ;
  level = 2 ;

  while ( (ch = getopt(argc, argv, "1f:i:l:n:N:q:t:w:x:")) != EOF ) {
    switch ( ch ) {
    default: g_assert_not_reached() ; break ;
    case 'f': nfld = atoi(optarg) ; break ;
    case 'i': ipfile = g_strdup(optarg) ; break ;
    case 'l': level = atoi(optarg) ; break ;
    case 'n': nsrc = atoi(optarg) ; break ;
    case 'N': N = atoi(optarg) ; break ;
    case 'q': quad = atoi(optarg) ; break ;
    case 't': test = parse_test(optarg) ; break ;
    case 'w': wb = atof(optarg) ; break ;
    case 'x': x = atof(optarg) ; break ;
    }
  }

  timer = g_timer_new() ;

  if ( ipfile != NULL ) {
    read_data(ipfile, xc, x0, &xs, &src, &nsrc, &xstride, &sstride,
	      &xf, &fstride, &nfld, ix, iy, iz) ;
  }

  if ( test == 0 ) {
    expansion_test(N, x0, xs, xstride, src, sstride, nsrc, xf, nfld) ;

    return 0 ;
  }

  if ( test == 1 ) {
    translation_test(N, x0, xs, xstride, src, sstride, nsrc, xf, nfld, x) ;
    
    return 0 ;
  }
  
  return 0 ;
}
