/* This file is part of WBFMM, a Wide-Band Fast Multipole Method code
 *
 * Copyright (C) 2019 Michael Carley
 *
 * WBFMM is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.  WBFMM is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with WBFMM.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <math.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include <glib.h>

#include <wbfmm.h>

#define BUFSIZE 131072

GTimer *timer ;

gchar *tests[] = {"expansion",
		  "translation",
		  "rotation",
		  "translationSR",
		  "translationRR",
		  "shift",
		  "child_parent",
		  ""} ;

#define wbfmm_index_laplace_nm(_n,_m) ((_n)*(_n)+(2*(_m))-1)

static gint parse_test(gchar *arg)

{
  gint i = 0 ;
  
  while ( strlen(tests[i]) != 0) {
    if ( !strcmp(tests[i], arg) ) return i ;
    i ++ ;
  }

  return -1 ;
}

static gint read_data(gchar *ipfile, WBFMM_REAL *xc, WBFMM_REAL *x0, 
		      WBFMM_REAL **xs, WBFMM_REAL **src, 
		      gint *nsrc, gint *xstride, gint *sstride,
		      WBFMM_REAL **xf, gint *fstride, gint *nfld,
		      WBFMM_REAL *ix,WBFMM_REAL *iy, WBFMM_REAL *iz)

{
  FILE *f ;
  gchar line[1024] ;
  gint i ;

  f = fopen(ipfile, "r") ;
  if ( f == NULL ) {
    fprintf(stderr, "cannot open %s\n", ipfile) ;
    exit (1) ;
  }

  fprintf(stderr, "reading %s\n", ipfile) ;
  
  while ( fscanf(f, "%[^\n]c", line) != EOF ) {
    if ( strncmp(line, "x0:", 3) == 0 ) {
      sscanf(&(line[3]), "%FLOATFMT %FLOATFMT %FLOATFMT",
	     &(x0[0]), &(x0[1]), &(x0[2])) ;
    }
    if ( strncmp(line, "xc:", 3) == 0 ) {
      sscanf(&(line[3]), "%FLOATFMT %FLOATFMT %FLOATFMT",
	     &(xc[0]), &(xc[1]), &(xc[2])) ;
    }

    if ( strncmp(line, "ix:", 3) == 0 ) {
      sscanf(&(line[3]), "%FLOATFMT %FLOATFMT %FLOATFMT",
	     &(ix[0]), &(ix[1]), &(ix[2])) ;
    }

    if ( strncmp(line, "iy:", 3) == 0 ) {
      sscanf(&(line[3]), "%FLOATFMT %FLOATFMT %FLOATFMT",
	     &(iy[0]), &(iy[1]), &(iy[2])) ;
    }

    if ( strncmp(line, "iz:", 3) == 0 ) {
      sscanf(&(line[3]), "%FLOATFMT %FLOATFMT %FLOATFMT",
	     &(iz[0]), &(iz[1]), &(iz[2])) ;
    }

    if ( strncmp(line, "sources:", 8) == 0 ) {
      sscanf(&(line[8]), "%d", nsrc) ;
      *xstride = 3 ; *sstride = 2 ;
      *xs = (WBFMM_REAL *)g_malloc((*nsrc)*(*xstride)*sizeof(WBFMM_REAL)) ;
      *src = (WBFMM_REAL *)g_malloc((*nsrc)*(*sstride)*sizeof(WBFMM_REAL)) ;
      for ( i = 0 ; i < *nsrc ; i ++ ) {
	fscanf(f, "%FLOATFMT %FLOATFMT %FLOATFMT %FLOATFMT %FLOATFMT",
	       &((*xs)[(*xstride)*i+0]),
	       &((*xs)[(*xstride)*i+1]),
	       &((*xs)[(*xstride)*i+2]),
	       &((*src)[(*sstride)*i+0]),
	       &((*src)[(*sstride)*i+1])) ;
      }
    }
    if ( strncmp(line, "field:", 6) == 0 ) {
      sscanf(&(line[6]), "%d", nfld) ;
      *fstride = 5 ;
      *xf = (WBFMM_REAL *)g_malloc((*nfld)*(*fstride)*sizeof(WBFMM_REAL)) ;
      for ( i = 0 ; i < *nfld ; i ++ ) {
	fscanf(f, "%FLOATFMT %FLOATFMT %FLOATFMT",
	       &((*xf)[(*fstride)*i+0]),
	       &((*xf)[(*fstride)*i+1]),
	       &((*xf)[(*fstride)*i+2])) ;
      }
    }

    fscanf(f, "%*c") ;
  }

  fprintf(stderr, "%s read\n", ipfile) ;

  fclose(f) ;

  return 0 ;
}

gint expansion_test(gint N, WBFMM_REAL *x0, WBFMM_REAL *xs,
		    gint xstride, WBFMM_REAL *src, gint sstride,
		    gint nsrc, WBFMM_REAL *xf, gint nfld)

{
  gint i, nq, cstr ;
  WBFMM_REAL cfft[BUFSIZE]={0.0}, work[8192]={0.0}, fc[8]={0.0}, ff[8]={0.0} ;

  nq = 2 ;
  fprintf(stderr, "expansion test\n") ;
  fprintf(stderr, "==============\n") ;
  fprintf(stderr,
	  "N = %d\n"
	  "x0 = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "xf = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "nsrc = %d\n",
	  N, x0[0], x0[1], x0[2], xf[0], xf[1], xf[2], nsrc) ;

  /*reference calculation*/
  wbfmm_laplace_field_PREC(xs, xstride, src, sstride, nq, NULL, 0, NULL, 0,
			   nsrc, xf, fc) ;

  cstr = 2 ;
  /*multipole expansion*/
  for ( i = 0 ; i < nsrc ; i ++ ) 
    wbfmm_expansion_laplace_cfft_PREC(N, x0, &(xs[i*xstride]),
				      &(src[i*sstride]), nq, cfft, cstr,
				      work) ;

  wbfmm_expansion_laplace_evaluate_PREC(x0, cfft, cstr, N, nq, xf, ff, work) ;
  
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", fc[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", ff[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-ff[i])) ;
  fprintf(stderr, "\n") ;
  
  return 0 ;
}

gint translation_test(gint N, WBFMM_REAL *x0, WBFMM_REAL *xs,
		      gint xstride, WBFMM_REAL *src, gint sstride,
		      gint nsrc, WBFMM_REAL *xf, gint nfld, WBFMM_REAL t)

{
  gint i, nq, cstr ;
  WBFMM_REAL Ci[BUFSIZE]={0.0}, work[8192]={0.0}, Co[BUFSIZE]={0.0} ;
  WBFMM_REAL fc[8]={0.0}, ff[8]={0.0}, ft[8]={0.0} ;

  nq = 2 ;
  fprintf(stderr, "translation test\n") ;
  fprintf(stderr, "==============\n") ;
  fprintf(stderr,
	  "N = %d\n"
	  "x0 = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "xf = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "t  = %FLOATFMT\n"
	  "nsrc = %d\n",
	  N, x0[0], x0[1], x0[2], xf[0], xf[1], xf[2], t, nsrc) ;

  /*reference calculation*/
  wbfmm_laplace_field_PREC(xs, xstride, src, sstride, nq, NULL, 0, NULL, 0,
			   nsrc, xf, fc) ;

  cstr = 4 ;
  /*multipole expansion*/
  for ( i = 0 ; i < nsrc ; i ++ ) 
    wbfmm_expansion_laplace_cfft_PREC(N, x0, &(xs[i*xstride]),
				      &(src[i*sstride]), nq, Ci, cstr,
				      work) ;

  wbfmm_expansion_laplace_evaluate_PREC(x0, Ci, cstr, N, nq, xf, ff, work) ;

  /*translate the expansion*/
  wbfmm_coaxial_translate_SS_laplace_PREC(Co, cstr, N, Ci, cstr, N, nq, t) ;

  x0[2] += t ;  
  wbfmm_expansion_laplace_evaluate_PREC(x0, Co, cstr, N, nq, xf, ft, work) ;
  
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", fc[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", ff[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-ff[i])) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", ft[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-ft[i])) ;
  fprintf(stderr, "\n") ;
  
  return 0 ;
}

gint translation_SR_test(gint N, WBFMM_REAL *x0, WBFMM_REAL *xs,
			 gint xstride, WBFMM_REAL *src, gint sstride,
			 gint nsrc, WBFMM_REAL *xf, gint nfld, WBFMM_REAL t)

{
  gint i, nq, cstr ;
  WBFMM_REAL Ci[BUFSIZE]={0.0}, work[8192]={0.0}, Co[BUFSIZE]={0.0} ;
  WBFMM_REAL fc[8]={0.0}, ff[8]={0.0}, ft[8]={0.0} ;

  nq = 2 ;
  fprintf(stderr, "singular to regular translation test\n") ;
  fprintf(stderr, "====================================\n") ;
  fprintf(stderr,
	  "N = %d\n"
	  "x0 = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "xf = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "t  = %FLOATFMT\n"
	  "nsrc = %d\n",
	  N, x0[0], x0[1], x0[2], xf[0], xf[1], xf[2], t, nsrc) ;

  /*reference calculation*/
  wbfmm_laplace_field_PREC(xs, xstride, src, sstride, nq, NULL, 0, NULL, 0,
			   nsrc, xf, fc) ;

  cstr = 4 ;
  /*multipole expansion*/
  for ( i = 0 ; i < nsrc ; i ++ ) 
    wbfmm_expansion_laplace_cfft_PREC(N, x0, &(xs[i*xstride]),
				      &(src[i*sstride]), nq, Ci, cstr,
				      work) ;

  wbfmm_expansion_laplace_evaluate_PREC(x0, Ci, cstr, N, nq, xf, ff, work) ;

  /*translate the expansion*/
  wbfmm_coaxial_translate_SR_laplace_PREC(Co, cstr, N, Ci, cstr, N, nq, t) ;

  x0[2] += t ;  
  wbfmm_expansion_laplace_local_evaluate_PREC(x0, Co, cstr, N, nq,
					      xf, ft, work) ;
  
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", fc[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", ff[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-ff[i])) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", ft[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-ft[i])) ;
  fprintf(stderr, "\n") ;
  
  return 0 ;
}

gint translation_RR_test(gint N, WBFMM_REAL *x0, WBFMM_REAL *xs,
			 gint xstride, WBFMM_REAL *src, gint sstride,
			 gint nsrc, WBFMM_REAL *xf, gint nfld, WBFMM_REAL t)

{
  gint i, nq, cstr ;
  WBFMM_REAL Ci[BUFSIZE]={0.0}, Co[BUFSIZE]={0.0}, Cr[BUFSIZE] = {0.0} ;
  WBFMM_REAL work[BUFSIZE]={0.0} ;
  WBFMM_REAL fc[8]={0.0}, ff[8]={0.0}, ft[8]={0.0} ;

  nq = 2 ;
  fprintf(stderr, "regular to regular translation test\n") ;
  fprintf(stderr, "====================================\n") ;
  fprintf(stderr,
	  "N = %d\n"
	  "x0 = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "xf = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "t  = %FLOATFMT\n"
	  "nsrc = %d\n",
	  N, x0[0], x0[1], x0[2], xf[0], xf[1], xf[2], t, nsrc) ;

  /*reference calculation*/
  wbfmm_laplace_field_PREC(xs, xstride, src, sstride, nq, NULL, 0, NULL, 0,
			   nsrc, xf, fc) ;

  cstr = 4 ;
  /*multipole expansion*/
  for ( i = 0 ; i < nsrc ; i ++ ) 
    wbfmm_expansion_laplace_cfft_PREC(N, x0, &(xs[i*xstride]),
				      &(src[i*sstride]), nq, Ci, cstr,
				      work) ;

  wbfmm_expansion_laplace_evaluate_PREC(x0, Ci, cstr, N, nq, xf, ff, work) ;

  /*translate the expansion, singular to regular*/
  wbfmm_coaxial_translate_SR_laplace_PREC(Co, cstr, N, Ci, cstr, N, nq,
					  t*0.9) ;
  /*translate the expansion, regular to regular*/
  wbfmm_coaxial_translate_RR_laplace_PREC(Cr, cstr, N, Co, cstr, N, nq,
					  t*0.1) ;  

  x0[2] += t ;  
  wbfmm_expansion_laplace_local_evaluate_PREC(x0, Cr, cstr, N, nq,
					      xf, ft, work) ;
  
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", fc[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", ff[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-ff[i])) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", ft[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-ft[i])) ;
  fprintf(stderr, "\n") ;
  
  return 0 ;
}

gint rotation_test(gint N, 
		   WBFMM_REAL *x0,
		   WBFMM_REAL *xs, gint xstride,
		   WBFMM_REAL *src, gint sstride,
		   gint nsrc,
		   WBFMM_REAL ix[], WBFMM_REAL iy[], 
		   WBFMM_REAL iz[],			  
		   WBFMM_REAL *xf, gint nfld)

{
  WBFMM_REAL H[BUFSIZE], work[BUFSIZE], th, ph, ch ;
  WBFMM_REAL ix0[3], iy0[3], iz0[3], y[3] ;
  WBFMM_REAL Ci[BUFSIZE] = {0.0}, Co[BUFSIZE] = {0.0}, Cc[BUFSIZE] = {0.0} ;
  WBFMM_REAL fc[8]={0.0}, ff[8]={0.0}, fr[8]={0.0} ;
  gint i, cstri, cstro, nq ;

  cstri = 3 ; cstro = 3 ; nq = 2 ;

  ix0[0] = 1.0 ; ix0[1] = 0.0 ; ix0[2] = 0.0 ;
  iy0[0] = 0.0 ; iy0[1] = 1.0 ; iy0[2] = 0.0 ;
  iz0[0] = 0.0 ; iz0[1] = 0.0 ; iz0[2] = 1.0 ;

  fprintf(stderr, "rotation test\n") ;
  fprintf(stderr, "==============\n") ;
  fprintf(stderr,
	  "N = %d\n"
	  "x0 = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "xf = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "nsrc = %d\n",
	  N, x0[0], x0[1], x0[2], xf[0], xf[1], xf[2], nsrc) ;

  wbfmm_rotation_angles_PREC(ix0, iy0, iz0, ix, iy, iz, &th, &ph, &ch) ;

  fprintf(stderr, "rotation: (%FLOATFMT,%FLOATFMT,%FLOATFMT)\n", th, ph, ch) ;

  /*reference calculation*/
  wbfmm_laplace_field_PREC(xs, xstride, src, sstride, nq, NULL, 0, NULL, 0,
			   nsrc, xf, fc) ;

  /*multipole expansion*/
  for ( i = 0 ; i < nsrc ; i ++ ) 
    wbfmm_expansion_laplace_cfft_PREC(N, x0, &(xs[i*xstride]),
				      &(src[i*sstride]), nq, Ci, cstri,
				      work) ;

  /*field from unrotated coefficients*/
  wbfmm_expansion_laplace_evaluate_PREC(x0, Ci, cstri, N, nq, xf, ff, work) ;

  wbfmm_coefficients_H_rotation_PREC(H, N, th, work) ;

  memset(Co, 0, BUFSIZE*sizeof(WBFMM_REAL)) ;
  /*apply the rotation to the coefficients*/
  wbfmm_rotate_H_laplace_PREC(Co, cstro, Ci, cstri, N, nq, H, ph, ch) ;
  memset(Cc, 0, BUFSIZE*sizeof(WBFMM_REAL)) ;
  /*reverse rotation as check*/
  /* wbfmm_rotate_H_laplace_PREC(Cc, cstro, Co, cstro, N, nq, H, ch, ph) ; */

  /* for ( i = 0 ; i < 32 ; i ++ ) */
  /*   fprintf(stderr, "%FLOATFMT %FLOATFMT %FLOATEXP\n", */
  /* 	    Ci[cstri*i], Cc[cstro*i], fabs(Ci[cstri*i]-Cc[cstro*i])) ; */
  
  /*from rotated coefficients*/
  wbfmm_coordinate_transform_PREC(xf, ix, iy, iz, y) ;
  wbfmm_expansion_laplace_evaluate_PREC(x0, Co, cstro, N, nq, y, fr, work) ;

  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", fc[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", ff[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-ff[i])) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", fr[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-fr[i])) ;
  fprintf(stderr, "\n") ;
  
  return 0 ;
}

gint shift_test(gint N, WBFMM_REAL *xc, WBFMM_REAL *x0, WBFMM_REAL *xs,
		gint xstride, WBFMM_REAL *src, gint sstride,
		gint nsrc, WBFMM_REAL *xf, gint nfld)

{
  gint i, nq, cstri, cstro, Ni, No ;
  WBFMM_REAL Ci[BUFSIZE]={0.0}, Co[BUFSIZE]={0.0} ;
  WBFMM_REAL Cr1[BUFSIZE] = {0.0}, Cr2[BUFSIZE] = {0.0} ;
  WBFMM_REAL H1[BUFSIZE] = {0.0}, H2[BUFSIZE] = {0.0} ;
  WBFMM_REAL work[BUFSIZE]={0.0} ;
  WBFMM_REAL r, th, ph, ch ;
  WBFMM_REAL fc[8]={0.0}, ff[8]={0.0}, ft[8]={0.0} ;

  nq = 1 ;
  fprintf(stderr, "shift test\n") ;
  fprintf(stderr, "==========\n") ;
  fprintf(stderr,
	  "N = %d\n"
	  "xc = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "x0 = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "xf = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "nsrc = %d\n",
	  N,
	  xc[0], xc[1], xc[2], x0[0], x0[1], x0[2], xf[0], xf[1], xf[2],
	  nsrc) ;

  Ni = N ; No = Ni + 5 ;
  /*reference calculation*/
  wbfmm_laplace_field_PREC(xs, xstride, src, sstride, nq, NULL, 0, NULL, 0,
			   nsrc, xf, fc) ;

  cstri = 1 ; cstro = 1 ;
  /*multipole expansion*/
  for ( i = 0 ; i < nsrc ; i ++ ) 
    wbfmm_expansion_laplace_cfft_PREC(Ni, x0, &(xs[i*xstride]),
				      &(src[i*sstride]), nq, Ci, cstri,
				      work) ;

  wbfmm_expansion_laplace_evaluate_PREC(x0, Ci, cstri, Ni, nq, xf, ff, work) ;

  /*shift coordinates*/
  wbfmm_shift_angles_PREC(x0, xc, &th, &ph, &ch, &r) ;

  fprintf(stderr, "rotation: (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n",
	  th, ph, ch) ;
  
  /*rotation operator*/
  wbfmm_coefficients_H_rotation_PREC(H1, Ni, th, work) ;

  /*rotate expansion*/
  wbfmm_rotate_H_laplace_PREC(Cr1, cstri, Ci, cstri, Ni, nq, H1, ph, ch) ;
  
  /*translate the expansion, singular to singular*/
  wbfmm_coaxial_translate_SS_laplace_PREC(Cr2, cstro, No, Cr1, cstri, Ni, nq, r) ;

  /*reverse rotation*/
  /* wbfmm_shift_angles_PREC(xc, x0, &th, &ph, &ch, &r) ; */
  wbfmm_coefficients_H_rotation_PREC(H2, No, th, work) ;
  fprintf(stderr, "rotation: (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n",
	  th, ph, ch) ;
  wbfmm_rotate_H_laplace_PREC(Co, cstro, Cr2, cstro, No, nq, H2, ch, ph) ;

  wbfmm_expansion_laplace_evaluate_PREC(xc, Co, cstro, No, nq,
					xf, ft, work) ;
  /*reverse rotation*/
  /* wbfmm_rotate_H_laplace_PREC(Co, cstro, Cr1, cstri, N, nq, H1, ch, ph) ; */
  /* wbfmm_expansion_laplace_evaluate_PREC(x0, Co, cstro, N, nq, xf, ft, work) ; */
  
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", fc[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", ff[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-ff[i])) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", ft[i]) ;
  fprintf(stderr, "\n") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-ft[i])) ;
  fprintf(stderr, "\n") ;

  return 0 ;
}

gint child_parent_test(gint N, WBFMM_REAL *x0, WBFMM_REAL wb, gint quad,
		       WBFMM_REAL *xs, gint xstride,
		       WBFMM_REAL *src, gint sstride,
		       gint nsrc, WBFMM_REAL *xf, gint nfld)

{
  WBFMM_REAL *Cc, *Cp, xc[3], xsc[3] ;
  gint i, nq, Nc, Np ;
  WBFMM_REAL H03[BUFSIZE] = {0.0}, H47[BUFSIZE] = {0.0} ;
  WBFMM_REAL work[BUFSIZE]={0.0} ;
  WBFMM_REAL cr[BUFSIZE] = {0.0}, ct[BUFSIZE] = {0.0}, crr[BUFSIZE] = {0.0} ;
  WBFMM_REAL r, th, ph, ch ;
  WBFMM_REAL fc[8] = {0.0}, fr[8] = {0.0}, fp[8] = {0.0}, fs[8] = {0.0} ;
  WBFMM_REAL th03, th47 ;

  nq = 1 ;
  Nc = N ; Np = N ;
  Cc = (WBFMM_REAL *)g_malloc0((Nc+1)*(Nc+1)*nq*8*sizeof(WBFMM_REAL)) ;
  Cp = (WBFMM_REAL *)g_malloc0((Np+1)*(Np+1)*nq*8*sizeof(WBFMM_REAL)) ;

  fprintf(stderr, "child-parent shift test\n") ;
  fprintf(stderr, "=======================\n") ;
  fprintf(stderr,
	  "Nc = %d; Np = %d;\n"
	  "x0 = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "xf = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "xs = (%FLOATFMT, %FLOATFMT, %FLOATFMT)\n"
	  "wb = %FLOATFMT;\n"
	  "quad = %d;\n"
	  "nsrc = %d\n",
	  Nc, Np,
	  x0[0], x0[1], x0[2], xf[0], xf[1], xf[2],
	  xs[0], xs[1], xs[2],
	  wb, quad, nsrc) ;

  /*generate child box coefficients*/
  switch ( quad ) {
  default: g_assert_not_reached() ;
  case 0:
    xc[0] = x0[0] - wb/2 ; xc[1] = x0[1] - wb/2 ; xc[2] = x0[2] - wb/2 ;
    break ;
  case 1:
    xc[0] = x0[0] + wb/2 ; xc[1] = x0[1] - wb/2 ; xc[2] = x0[2] - wb/2 ;
    break ;
  case 2:
    xc[0] = x0[0] - wb/2 ; xc[1] = x0[1] + wb/2 ; xc[2] = x0[2] - wb/2 ;
    break ;
  case 3:
    xc[0] = x0[0] + wb/2 ; xc[1] = x0[1] + wb/2 ; xc[2] = x0[2] - wb/2 ;
    break ;
  case 4:
    xc[0] = x0[0] - wb/2 ; xc[1] = x0[1] - wb/2 ; xc[2] = x0[2] + wb/2 ;
    break ;
  case 5:
    xc[0] = x0[0] + wb/2 ; xc[1] = x0[1] - wb/2 ; xc[2] = x0[2] + wb/2 ;
    break ;
  case 6:
    xc[0] = x0[0] - wb/2 ; xc[1] = x0[1] + wb/2 ; xc[2] = x0[2] + wb/2 ;
    break ;
  case 7:
    xc[0] = x0[0] + wb/2 ; xc[1] = x0[1] + wb/2 ; xc[2] = x0[2] + wb/2 ;
    break ;
  }
  
  xsc[0] = xc[0] + xs[0] ; xsc[1] = xc[1] + xs[1] ; xsc[2] = xc[2] + xs[2] ; 
  /* xsc[0] = x0[0]; xsc[1] = x0[1] ; xsc[2] = x0[2] ; */

  wbfmm_expansion_laplace_cfft_PREC(Nc, xc, xsc, src, nq,
				    &(Cc[quad*nq]), nq*8, work) ;
  wbfmm_expansion_laplace_evaluate_PREC(xc, &(Cc[quad*nq]), nq*8,
					Nc, nq, xf, fc, work) ;
  wbfmm_laplace_field_PREC(xsc, xstride, src, sstride, nq, NULL, 0, NULL, 0,
			   nsrc, xf, fr) ;

  /*rotations and translations for child-parent shift*/
  th03 = acos(sqrt(1.0/3.0)) ; th47 = M_PI - th03 ;
  r = sqrt(3.0)*0.5*wb ;
  wbfmm_coefficients_H_rotation_PREC(H03, Np, th03, work) ;
  wbfmm_coefficients_H_rotation_PREC(H47, Np, th47, work) ;

  /* Np = Nc = 0 ; */
  fprintf(stderr, "child parent shift:\n") ;
  wbfmm_child_parent_shift_laplace_PREC(Cp, Np, Cc, Nc, nq, H03, H47, Np,
					r, work) ;
  memset(work, 0, BUFSIZE*sizeof(WBFMM_REAL)) ;

  /*same thing using a sequence of reference functions*/
  wbfmm_shift_angles_PREC(xc, x0, &th, &ph, &ch, &r) ;
  /* ph = 0.5*M_PI ; */
  /* fprintf(stderr, "th = %lg; ph = %lg; ch = %lg;\n", th, ph, ch) ; */
  wbfmm_coefficients_H_rotation_PREC(H03, Np, th, work) ;
  wbfmm_rotate_H_laplace_PREC(cr, nq, &(Cc[quad*nq]), 8*nq, Nc, nq, H03,
			      ph, ch) ;
  /* fprintf(stderr, "%lg %lg %lg %lg %lg %lg %lg %lg %lg\n", */
  /* 	  cr[0*nq + 0], */
  /* 	  cr[1*nq + 0], */
  /* 	  cr[2*nq + 0], cr[2*nq + 1], */
  /* 	  cr[4*nq + 0], */
  /* 	  cr[5*nq + 0], cr[5*nq + 1], */
  /* 	  cr[7*nq + 0], cr[7*nq + 1]) ; */

  wbfmm_coaxial_translate_SS_laplace_PREC(ct, nq, Np, cr, nq, Nc, nq, r) ;
  /* fprintf(stderr, "%lg %lg %lg %lg %lg %lg %lg %lg %lg\n", */
  /* 	  ct[0*nq + 0], */
  /* 	  ct[1*nq + 0], */
  /* 	  ct[2*nq + 0], ct[2*nq + 1], */
  /* 	  ct[4*nq + 0], */
  /* 	  ct[5*nq + 0], ct[5*nq + 1], */
  /* 	  ct[7*nq + 0], ct[7*nq + 1]) ; */
  wbfmm_rotate_H_laplace_PREC(crr, nq, ct, nq, Np, nq, H03, ch, ph) ;
  /* fprintf(stderr, "%lg %lg %lg %lg %lg %lg %lg %lg %lg\n", */
  /* 	  crr[0*nq + 0], */
  /* 	  crr[1*nq + 0], */
  /* 	  crr[2*nq + 0], crr[2*nq + 1], */
  /* 	  crr[4*nq + 0], */
  /* 	  crr[5*nq + 0], crr[5*nq + 1], */
  /* 	  crr[7*nq + 0], crr[7*nq + 1]) ; */

  wbfmm_expansion_laplace_evaluate_PREC(x0, Cp, nq*8, Np, nq, xf, fp, work) ;
  wbfmm_expansion_laplace_evaluate_PREC(x0, crr, nq, Np, nq, xf, fs, work) ;

  fprintf(stderr, "ref:   ") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", fr[i]) ;
  fprintf(stderr, "\n") ;
  fprintf(stderr, "child: ") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", fc[i]) ;
  fprintf(stderr, "\n") ;
  fprintf(stderr, "shift: ") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", fp[i]) ;
  fprintf(stderr, "\n") ;
  fprintf(stderr, "chain: ") ;
  for ( i = 0 ; i < nq ; i ++ ) fprintf(stderr, "%FLOATFMT ", fs[i]) ;
  fprintf(stderr, "\n") ;

  fprintf(stderr, "child: ") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fc[i]-fr[i])) ;
  fprintf(stderr, "\n") ;
  fprintf(stderr, "shift: ") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fp[i]-fr[i])) ;
  fprintf(stderr, "\n") ;
  fprintf(stderr, "chain: ") ;
  for ( i = 0 ; i < nq ; i ++ )
    fprintf(stderr, "%FLOATEXP ", fabs(fs[i]-fr[i])) ;
  fprintf(stderr, "\n") ;
  
  return 0 ;
}


gint main(gint argc, gchar **argv)

{
  WBFMM_REAL *xs, *src, *xf, wb ;
  WBFMM_REAL x, r, x0[3] = {0.0}, xc[3] = {0.0} ;
  WBFMM_REAL ix[3] = {0}, iy[3] = {0}, iz[3] = {0} ;
  gint nsrc, sstride, xstride, fstride, N, i, nfld, test, quad ;
  gchar ch, *ipfile ;
  guint level ;

  N = 16 ; 
  sstride = 2 ; xstride = 3 ; 
  r = 0.25 ;
  nsrc = 1 ;
  nfld = 1 ;
  x = 0.025 ;
  test = -1 ;
  ipfile = NULL ;
  ix[0] = iy[1] = iz[2] = 1.0 ; 
  xs = src = xf = NULL ;
  wb = 0.125 ;
  quad = 0 ;
  level = 2 ;

  while ( (ch = getopt(argc, argv, "1f:i:l:n:N:q:t:w:x:")) != EOF ) {
    switch ( ch ) {
    default: g_assert_not_reached() ; break ;
    case 'f': nfld = atoi(optarg) ; break ;
    case 'i': ipfile = g_strdup(optarg) ; break ;
    case 'l': level = atoi(optarg) ; break ;
    case 'n': nsrc = atoi(optarg) ; break ;
    case 'N': N = atoi(optarg) ; break ;
    case 'q': quad = atoi(optarg) ; break ;
    case 't': test = parse_test(optarg) ; break ;
    case 'w': wb = atof(optarg) ; break ;
    case 'x': x = atof(optarg) ; break ;
    }
  }

  timer = g_timer_new() ;

  if ( ipfile != NULL ) {
    read_data(ipfile, xc, x0, &xs, &src, &nsrc, &xstride, &sstride,
	      &xf, &fstride, &nfld, ix, iy, iz) ;
  }

  if ( test == 0 ) {
    expansion_test(N, x0, xs, xstride, src, sstride, nsrc, xf, nfld) ;

    return 0 ;
  }

  if ( test == 1 ) {
    translation_test(N, x0, xs, xstride, src, sstride, nsrc, xf, nfld, x) ;
    
    return 0 ;
  }

  if ( test == 2 ) {
    rotation_test(N, x0, xs, xstride, src, sstride, nsrc,
		  ix, iy, iz, xf, nfld) ;
    return 0 ;
  }
  
  if ( test == 3 ) {
    translation_SR_test(N, x0, xs, xstride, src, sstride, nsrc, xf, nfld, x) ;
    
    return 0 ;
  }

  if ( test == 4 ) {
    translation_RR_test(N, x0, xs, xstride, src, sstride, nsrc, xf, nfld, x) ;
    
    return 0 ;
  }

  if ( test == 5 ) {
    shift_test(N, xc, x0, xs, xstride, src, sstride, nsrc, xf, nfld) ;
    
    return 0 ;
  }

  if ( test == 6 ) {
    child_parent_test(N, x0, wb, quad, xs, xstride, src, sstride, nsrc,
		      xf, nfld) ;
    
    return 0 ;
  }

  return 0 ;
}
